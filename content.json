{"meta":{"title":"靳中","subtitle":"靳中的博客","description":"日常学习与技术交流的个人博客","author":{"name":"kingdom","link":"http://www.baofengketang.com"},"url":"http://baofengketang.com"},"pages":[{"title":"about","date":"2018-04-09T08:34:07.000Z","updated":"2018-06-04T06:14:13.000Z","comments":true,"path":"about/index.html","permalink":"http://baofengketang.com/about/index.html","excerpt":"","text":"关于我#我#大家好，我是靳中，网名：Kingdom,这是我的个人博客主要用来分享自己在软件开发，项目管理、学习分享，以及生活中的感悟，我希望通过自己的分享与你共同进步 欢迎大家扫描微信二维码，共同讨论技术微信技术讨论1001群"},{"title":"search","date":"2018-04-09T08:35:29.000Z","updated":"2018-04-10T06:03:05.000Z","comments":true,"path":"search/index.html","permalink":"http://baofengketang.com/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-10T05:39:39.000Z","updated":"2018-04-10T05:39:39.000Z","comments":true,"path":"tags/index.html","permalink":"http://baofengketang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript面向对象","slug":"javascript/js01","date":"2018-06-27T13:54:15.000Z","updated":"2018-06-27T13:54:15.000Z","comments":true,"path":"2018/06/27/javascript/js01/","link":"","permalink":"http://baofengketang.com/2018/06/27/javascript/js01/","excerpt":"","text":"JavaScript面向对象 JavaScript中创建对象的方式 普通创建方式 通过json格式创建对象 工厂方法创建对象 构造函数创建的对象 采用原型创建对象 JavaScript中的继承机制 对象冒充 apply和call方法 原型混合方式 JavaScript面向对象#JavaScript中创建对象的方式#普通创建方式#1234567891011121314&lt;script type=\"text/javascript\"&gt; var obj = new Object(); //动态添加属性 obj.name=\"张三\"; obj.age = 15 ; obj[\"addr\"]=\"铜锣湾\"; obj.sayHello=function()&#123; console.log(\"姓名：\"+this.name+\",年龄\"+this.age+\",地址:\"+this.addr); &#125; obj.sayHello(); //动态删除属性 delete obj.addr; obj.sayHello();&lt;/script&gt; 在js中，属性可以动态添加，也可以动态删除 通过json格式创建对象#json的格式的表现形式 表现形式1 12345&lt;script type=\"text/javascript\"&gt; var obj=&#123;\"name\":\"zhangsan\",\"age\":15,\"addr\":\"南京\"&#125;; console.log(obj.name,obj.age,obj.addr); console.log(typeof obj); &lt;/script&gt; 表现形式2 注意：value的取值可以是以下内容 对于以上的结构，那么json的变种就非常丰富 案例1: 12345678910var obj=[\"张三\",15,true, &#123; \"fatherName\":\"张无忌\", \"motherName\":\"无忌张\", children:[\"张飞\",\"张亮\",\"张靓颖\"] &#125; ];alert(typeof obj)alert(obj[0]);alert(obj[3][\"children\"]) 案例2： 12345678910111213141516171819202122232425 var obj3= &#123; \"name\":\"zhangsan\", \"age\":15, children:[ &#123; name:\"张一\", age:1 &#125;, &#123; name:\"lisi\", age:10 &#125;, &#123; name:\"wangwu\", age:12 &#125; ], sayInfo:function()&#123; console.log(this.name,this.age); &#125; &#125;;obj3.sayInfo();for(var i = 0 ;i&lt;obj3.children.length;i++) &#123; console.log(obj3.children[i].name,obj3.children[i].age)&#125; 工厂方法创建对象#1234567891011121314function createObject(name,age)&#123; var obj = new Object(); obj.name = name ; obj.age = age obj.sayHello=sayHello; return obj ; &#125;var sayHello=function()&#123; console.log(this.name,this.age);&#125;var obj1 = createObject(\"张三\",12);obj1.sayHello();var obj2 = createObject(\"李四\",20);obj2.sayHello(); 构造函数创建的对象#123456789101112131415&lt;script type=\"text/javascript\"&gt;function Person(name,age)&#123; this.name = name ; this.age =age ; this.sayHello= sayHello;&#125;function sayHello()&#123; console.log(this.name,this.age)&#125;//隐藏了一个创建的对象的过程var p1 =new Person(\"张三\",12);var p2 = new Person(\"李四\",15);p1.sayHello();p2.sayHello();&lt;/script&gt; 采用原型创建对象#12345678910111213&lt;script type=\"text/javascript\"&gt; function Person(name,age)&#123; this.name = name ; this.age = age ; &#125; Person.prototype.sayHello = function()&#123; console.log(this.name,this.age); &#125; var p1 = new Person(\"张三\",15); var p2 = new Person(\"lisi\",16); p1.sayHello(); p2.sayHello();&lt;/script&gt; 使用原型+构造函数方式来定义对象，对象之间的属性互不干扰，各个对象间共享同一个方法 优化上面的案例 12345678910111213141516171819&lt;script type=\"text/javascript\"&gt; function Person(name,age) &#123; this.name = name ; this.age = age ; //第一次创建对象的，通过参数给原型上增加一个共享的方法 if(typeof Person.prototype.flag===\"undefined\") &#123; alert(\"invoked...\"); Person.prototype.sayInfo = function()&#123; console.log(this.name,this.age) &#125;; Person.prototype.flag = true ; &#125; &#125; var p1 = new Person(\"zhangsan\",12); var p2 = new Person(\"lisi\",15); p1.sayInfo(); p2.sayInfo()&lt;/script&gt; JavaScript中的继承机制#对象冒充#1234567891011121314151617function Parent(name,age) &#123; this.name= name ; this.age = age ; this.sayInfo = function()&#123; console.log(this.name,this.age) ; &#125; &#125;function Son(name,age,addr) &#123; this.method=Parent; this.method(name,age); this.addr = addr ; //将自定义的method方法删除掉 delete this.method; this.sayInfo=function()&#123; console.log(this.name,this.age,this.addr) ; &#125;&#125; apply和call方法#1234567891011121314151617181920function Parent(name,age) &#123; this.name = name ; this.age = age ; this.sayInfo=function()&#123; console.log(this.name,this.age); &#125;;&#125;function Son(name,age,addr) &#123; //call接受的离散的值,apply的参数为数组 //Parent.call(this,name,age); Parent.apply(this,new Array(name,age)); this.addr = addr ; this.sayInfo=function()&#123; console.log(this.name,this.age,this.addr); &#125;&#125;var s = new Son(\"张三\",15,\"北京\");console.log(s)s.sayInfo(); 原型混合方式#123456789101112131415161718192021&lt;script type=\"text/javascript\"&gt; //apply|call+原型混合方式 function Parent(name,age) &#123; this.name = name ; this.age = age ; &#125; Parent.prototype.sayInfo=function()&#123; console.log(this.name,this.age); &#125; function Son(name,age,addr) &#123; //只能做属性复制 Parent.apply(this,new Array(name,age)); this.addr = addr ; &#125; //拿原型中方法 Son.prototype=new Parent(); var s = new Son(\"zhangsan\",12); console.log(s)&lt;script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://baofengketang.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://baofengketang.com/tags/JavaScript/"}]},{"title":"css学习笔记","slug":"css/css01","date":"2018-06-26T14:33:09.000Z","updated":"2018-06-26T15:49:15.000Z","comments":true,"path":"2018/06/26/css/css01/","link":"","permalink":"http://baofengketang.com/2018/06/26/css/css01/","excerpt":"","text":"css#概述#现在的互联网的前端三层 html:超文本标记语言，从语义的角度来描述页面结构 css:层叠样式表，从审美的角度负责页面样式 js:JavaScript，从交互的角度来描述页面的行为 css整体感知#css是层叠样式表cascading style sheet 层叠样式表的简写，css最新的版本是3，目前主要讲解的是2，因为css3和css2不矛盾，必须先学习2然后再学习3 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;01-css基本认识&lt;/title&gt; &lt;style type=\"text/css\"&gt; p&#123; color:blue; font-size:30px; text-decoration: underline; font-weight: bold; text-align: center; font-style: italic; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一段文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 我们写css的地方就是style标签，就是样式的意思，写在head里面，在后面的内容中，我们知道css也可以写在一个单独的文件中，这里我们为了讲解我们先在style标签里面 选择器的语法： 12345选择器｛ k:v; k:v; ..｝ css对换行不敏感，对空格也不敏感，但是一定要有标准的语法，冒号，分号不能省略 常见属性介绍#文本属性#color:字体颜色 font-family:什么字体 font-weight:字体是否加粗 font-size:字体大小(单位像素) font-style:italic|normal text-decoration:underline|none 背景属性#background-color:背景颜色 background-image:url(路径):背景图 background-position:偏移量 background-repeat:平铺方式（no-repeat|repeat-x|repeat-y|repeat） 基础选择器#标签选择器#就是以标签的名字命名 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;01-css基本认识&lt;/title&gt; &lt;style type=\"text/css\"&gt; span&#123; color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;HelloWorld&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 注意： 所有的标签，都可以是选择器，比如ul,li,label,dt,input等 无论这个标签藏的多深，一定能够被选择上 标签选择器，选择的是页面上所有的这种类型的标签，所以经常描述“共性”,无法描述某个元素“个性” ID选择器#ID选择器的选择符为“＃”，对于任何的html标签都可以有id属性，表示这个标签的名字，这个标签的名字可以任取的，但是 只能有字母，数字，下划线 必须以字母开头 不能和标签同名，比如id不能叫body，img,a 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;01-css基本认识&lt;/title&gt; &lt;style type=\"text/css\"&gt; span&#123; color:red; &#125; #divContainer&#123; width:300px; height:300px; background-color: azure; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"divContainer\"&gt; &lt;span&gt;HelloWorld&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在html页面中，不能出现相同的id，哪怕她们不是一个类型，比如页面中有一个id为hello的p元素，一个id为hello的div，都是非法的～","categories":[{"name":"css","slug":"css","permalink":"http://baofengketang.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://baofengketang.com/tags/css/"}]},{"title":"JavaScript正则表达式","slug":"javascript/reg_01","date":"2018-06-26T11:29:13.000Z","updated":"2018-06-26T14:13:37.000Z","comments":true,"path":"2018/06/26/javascript/reg_01/","link":"","permalink":"http://baofengketang.com/2018/06/26/javascript/reg_01/","excerpt":"","text":"复习String的几个方法 String对象的search方法 String对象-substring方法 String-charAt() String-split 为什么要使用正则表达式呢 通过传统的方式完成 通过正则表达式完成 什么是正则表达式 String类对正则表达式的支持 String-search方法 String-match方法 String-replace方法 复习String的几个方法#String对象的search方法#12var str='abcdef';alert(str.search('g')); String对象-substring方法#123var str='abcdef';//alert(str.substring(1, 4));alert(str.substring(1)); String-charAt()#12var str='abcdef';alert(str.charAt(2)); String-split#123var str='abc-12-u-qw';var arr=str.split('-');alert(arr[0]); 为什么要使用正则表达式呢#先通过一个案例：找出字符串中的所有的数字 通过传统的方式完成#12345678910111213141516171819202122&lt;script type=\"text/javascript\"&gt; var str =\"ba14ac6d899a12233\";//结果为:14,6,899,12233 var array = []; var buffer = \"\" ; for(var i = 0 ;i&lt;str.length;i++) &#123; if(str.charAt(i)&gt;='0' &amp;&amp; str.charAt(i)&lt;='9')&#123; buffer =buffer+str.charAt(i); &#125;else&#123; if(buffer) &#123; array.push(buffer); buffer=\"\"; &#125; &#125; &#125; if(buffer)&#123; array.push(buffer); &#125; for(var i = 0;i&lt;array.length;i++) &#123; document.write(array[i]+\"&amp;nbsp;&amp;nbsp;\") &#125;&lt;/script&gt; 通过正则表达式完成#123456&lt;script type=\"text/javascript\"&gt; var str =\"ba14ac6d899a12233\"; var reg = /\\d+/g; var msg = str.match(reg); alert(msg);&lt;/script&gt; 什么是正则表达式#正则表示一种规则，它是一种强大的字符串匹配工具。 正则表达式的写法有两种 12var reg1 = new RegExp(\"a\",\"i\");var reg2 = /a/i 我们一般采用第二种方式来定义一个正则表达式 案例：创建正则表达式 12345&lt;script type=\"text/javascript\"&gt; var str= \"abcdedfg\"; var reg1 = new RegExp(\"a\") ; alert(reg1.test(str));&lt;/script&gt; 该正则表达式用于检测字符串中是否包含a,但是对于大写的A不能检测到 123456&lt;script type=\"text/javascript\"&gt; var str='Abcdef'; //var re=new RegExp('a', 'i'); var re=/a/i; alert(re.test(str));&lt;/script&gt; String类对正则表达式的支持#String-search方法#案例1:搜索第一次出现b的位置 1234&lt;script&gt;var str='abcdef';alert(str.search(/b/));&lt;/script&gt; 案例2:搜索第一次出现数字的位置 12345&lt;script&gt;var str='asdf 443 vczxv 55';var re=/\\d/;alert(str.search(re));&lt;/script&gt; 案例3:通过正则表达式，显示用户用的浏览器 123456789101112131415&lt;script&gt; //alert(window.navigator.userAgent); if(window.navigator.userAgent.search(/firefox/i)!=-1) &#123; alert('ff'); &#125; else if(window.navigator.userAgent.search(/chrome/i)!=-1) &#123; alert('chrome'); &#125; else if(window.navigator.userAgent.search(/msie 9/i)!=-1) &#123; alert('IE9'); &#125;&lt;/script&gt; String-match方法#12345&lt;script&gt;var str='sdf e443 fedef 55 66gg 333322312 dff 99';var re=/\\d+/g;alert(str.match(re));&lt;/script&gt; String-replace方法#1234&lt;script&gt;var str='abacdAef';alert(str.replace(/a/gi, 'T'));&lt;/script&gt; 案例：敏感词 1234567891011121314151617181920212223242526&lt;!DOCTYPE &gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;script&gt;window.onload=function ()&#123; var oTxt1=document.getElementById('txt1'); var oTxt2=document.getElementById('txt2'); var oBtn=document.getElementById('btn1'); oBtn.onclick=function () &#123; var re=/我们|你们|他们/g; //|表示或者的含义 oTxt2.value=oTxt1.value.replace(re, '***'); &#125;;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;转换前&lt;textarea id=\"txt1\" rows=\"10\" cols=\"40\"&gt;&lt;/textarea&gt;&lt;br /&gt;&lt;input id=\"btn1\" type=\"button\" value=\"过滤\" /&gt;&lt;br /&gt;转换后&lt;textarea id=\"txt2\" rows=\"10\" cols=\"40\"&gt;&lt;/textarea&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://baofengketang.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://baofengketang.com/tags/JavaScript/"}]},{"title":"Idea下建立web项目","slug":"javaweb/web01","date":"2018-06-15T02:50:56.000Z","updated":"2018-06-15T03:31:21.000Z","comments":true,"path":"2018/06/15/javaweb/web01/","link":"","permalink":"http://baofengketang.com/2018/06/15/javaweb/web01/","excerpt":"","text":"创建一个web项目 配置工程目录 配置文件夹路径 配置外部依赖 配置tomcat服务器 启动服务器 创建一个web项目# 配置工程目录# 配置文件夹路径# 配置外部依赖# 配置tomcat服务器# 启动服务器#","categories":[{"name":"javaweb","slug":"javaweb","permalink":"http://baofengketang.com/categories/javaweb/"}],"tags":[{"name":"javaweb","slug":"javaweb","permalink":"http://baofengketang.com/tags/javaweb/"}]},{"title":"webstrom的安装","slug":"tools/webstrom","date":"2018-06-15T02:21:06.000Z","updated":"2018-06-15T02:25:26.000Z","comments":true,"path":"2018/06/15/tools/webstrom/","link":"","permalink":"http://baofengketang.com/2018/06/15/tools/webstrom/","excerpt":"","text":"webstorm的安装与使用#简介#WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。被广大中国JS开发者誉为”Web前端开发神器”、”最强大的HTML5编辑器”、”最智能的JavaScript IDE”等。 安装#点击进入官网下载最新版本进行安装. 下载之后进行安装 一路next即可 激活#下载相关jar包：JetbrainsCrack-2.6.10-release-enc.jar，将jar包拷贝到C:\\Program Files\\JetBrains\\WebStorm 2017.3.3\\bin目录中 还是在bin目录下，找到idea.exe.vmoptions和idea64.exe.vmoptions，用记事本打开它们，在两个文件最后分别加上： 1-javaagent:C:\\Program Files\\JetBrains\\WebStorm 2017.3.3\\bin\\JetbrainsCrack-2.6.10-release-enc.jar 重新启动webstrom，然后输入以下代码 123456789101112131415161718192021222324ThisCrackLicenseId-&#123;&quot;licenseId&quot;:&quot;ThisCrackLicenseId&quot;,&quot;licenseeName&quot;:&quot;你想要的用户名&quot;,&quot;assigneeName&quot;:&quot;&quot;,&quot;assigneeEmail&quot;:&quot;随便填一个邮箱(我填的:183588002@qq.com)&quot;,&quot;licenseRestriction&quot;:&quot;For This Crack, Only Test! Please support genuine!!!&quot;,&quot;checkConcurrentUse&quot;:false,&quot;products&quot;:[&#123;&quot;code&quot;:&quot;II&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;DM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;AC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;RS0&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;WS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;DPN&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;RC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;PS&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;DC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;RM&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;CL&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;,&#123;&quot;code&quot;:&quot;PC&quot;,&quot;paidUpTo&quot;:&quot;2099-12-31&quot;&#125;],&quot;hash&quot;:&quot;2911276/0&quot;,&quot;gracePeriodDays&quot;:7,&quot;autoProlongated&quot;:false&#125; 至此，webstrom就安装完毕了~，下面就可以开始骚气的玩耍了~~~ 欢迎扫描我的微信，进行技术交流","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://baofengketang.com/categories/开发工具/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://baofengketang.com/tags/开发工具/"}]},{"title":"jquery基础（一）","slug":"jquery/jquery_01","date":"2018-06-07T02:54:08.000Z","updated":"2018-06-07T08:41:42.000Z","comments":true,"path":"2018/06/07/jquery/jquery_01/","link":"","permalink":"http://baofengketang.com/2018/06/07/jquery/jquery_01/","excerpt":"","text":"Jquery基础 为什么要学习Jquery Jquery的优势 使用jquery解决上面的问题 Jquery的基本使用 什么是Jquery 下载Jquery源码 引入jquery 入口函数 事件处理 Jquery详细介绍 $符号介绍 jquery入口函数 Jquery中选择器（参考api） 基本选择器 层级选择器 过滤选择器 属性选择器 Jquery基础#为什么要学习Jquery#在看这个问题前，我们先来看一段代码. 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;回顾js&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; height: 200px; background: pink; margin-bottom: 10px; display: none; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; document.getElementById(\"demo\").onclick = function () &#123; var divs = document.getElementsByTagName(\"div\"); for(var i = 0; i &lt; divs.length; i++)&#123; divs[i].style.display = \"block\"; divs[i].innerHTML = \"javascript回顾\"; &#125; &#125; &#125; /*window.onload = function () &#123; alert(\"我是第二个onload\"); &#125;*/ &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"测试\" id=\"demo\"/&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; window.onload 事件有个事件覆盖的问题，我们只能写一个，代码容错性差，浏览器兼容性问题，书写很繁琐，代码量多，动画效果实现起来也是比较复杂等 Jquery的优势# 1、轻量级 ​ JQuery非常轻巧，采用Dean Edwards编写的Packer压缩后，大小不到30KB,如果使用Min版并且在服务器端启用Gzip压缩后，大小只有18KB。 2、强大的选择器 ​ JQuery允许开发者使用从CSS1到CSS3几乎所有的选择器，以及JQuery独创的高级而且复杂的选择器，另外还可以加入插件使其支持XPath选择器，甚至开发者可以编写属于自己的选择器。由于JQuery支持选择器这一特性，因此有一定CSS经验的开发人员可以很容易的切入到JQuery的学习中来。 3、出色的DOM操作的封装 ​ JQuery封装了大量常用的DOM操作，使开发者在编写DOM操作相关程序的时候能够得心应手。JQuery轻松地完成各种原本非常复杂的操作，让JavaScript新手也能写出出色的程序。 4、可靠的事件处理机制 ​ JQuery的事件处理机制吸收了JavaScript专家Dean Edwards编写的事件处理函数的精华，是的JQuery在处理事件绑定的时候相当可靠。在预留退路、循序渐进以及非入侵式编程思想方面，JQuery也做得非常不错。 5、完善的Ajax ​ JQuery将所有的Ajax操作封装到一个函数$.ajax()里，使得开发者处理Ajax的时候能够专心处理业务逻辑而无需关心复杂的浏览器兼容性和XMLHttpRequest对象的创建和使用的问题。 6、不污染顶级变量 ​ JQuery只建立一个名为JQuery的对象，其所有的函数方法都在这个对象之下。其别名$也可以随时交流控制权，绝对不会污染其他的对象。该特性是JQuery可以与其他JavaScript库共存，在项目中放心地引用而不需要考虑到后期的冲突。 7、出色的浏览器兼容性 ​ 作为一个流行的JavaScript库，浏览器的兼容性是必须具备的条件之一。JQuery能够在IE6.0+,FF 2+,Safari2.+和Opera9.0+下正常运行。JQuery同时修复了一些浏览器之间的的差异，使开发者不必在开展项目前建立浏览器兼容库。 8、链式操作方式 ​ JQuery中最有特色的莫过于它的链式操作方式——即对发生在同一个JQuery对象上的一组动作，可以直接接连写无需要重复获取对象。这一特点使得JQuery的代码无比优雅。 9.隐式迭代 ​ 当用JQuery找到带有“.myClass”类的全部元素，然后隐藏他们时。无需循环遍历每一个返回的元素。相反，JQuery里的方法都被设计成自动操作的对象集合，而不是单独的对象，这使得大量的循环结构变得不再必要，从而大幅度地减少代码量。 10、行为层与结构层的分离 ​ 开发者可以使用选择器选中元素，然后直接给元素添加事件。这种将行为层与结构层完全分离的思想，可以使JQuery开发人员和HTML或其他页面开发人员各司其职，摆脱过去开发冲突或个人单干的开发模式。同时，后期维护也非常方便，不需要在HTML代码中寻找某些函数和重复修改HTML代码。 11、丰富的插件支持 ​ JQuery的易扩展性，吸引了来自全球开发者来编写JQuery的扩展插件。目前已经有超过几百种官方插件支持，而且还不断有新插件面试。 12、完善的文档 ​ JQuery的文档非常丰富，现阶段多位英文文档，中文文档相对较少。很多热爱JQuery的团队都在努力完善JQuery中文文档，例如JQuery的中文API。 13、开源: JQuery是一个开源的产品，任何人都可以自由地使用并提出修改意见 使用jquery解决上面的问题#对于这个案例目前只需要看的懂即可，后面会详细介绍 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;jQuery解决问题&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; height: 200px; background: pink; margin-bottom: 10px; display: none; &#125; &lt;/style&gt; &lt;script src=\"js/jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt; // 1. 入口函数的方式 $(document).ready(function () &#123; $(\"#demo\").click(function () &#123; $(\"div\").show(1000).html(\"我是内容\"); &#125;); &#125;); // 2.函数定义的第二种方式 $(function () &#123; &#125;); //可以写多个入口函数 /*$(document).ready(function () &#123; alert(\"我是第二个onload\"); &#125;);*/ &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"我是按钮\" id=\"demo\"/&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Jquery的基本使用#什么是Jquery#jQuery就是javascript的一个库，把我们常用的一些功能进行了封装，方便我们来调用，提高我们的开发效率 Javascript是一门编程语言，我们用它来编写客户端浏览器脚本。 jQuery是javascript的一个库，包含多个可重用的函数，用来辅助我们简化javascript开发 jQuery能做的javascipt都能做到，而javascript能做的事情，jQuery不一定能做到。 下载Jquery源码# jquery提供了2个形式 jquery-1.11.1.js主要用于开发环境，学习我们主要使用此版本 jquery-1.11.1.min.js:主要用于线上环境 引入jquery#要把我们的jQuery源文件拿到我们的项目里面来，在我们的页面中引用jQuery文件 1&lt;script src=\"js/jquery-1.11.1.js\"&gt;&lt;/script&gt; 入口函数#定义方式一： 123$(document).ready(function () &#123; alert(\"helloworld\")&#125;); 定义方式二： 123$(function () &#123;alert(\"helloworld\")&#125;); 事件处理#JavaScript事件的处理方式 123document.getElementById(\"demo\").onclick=function()&#123; &#125; Jquery的事件处理机制 123$(\"#demo\").click(function()&#123; alert(\"jquery的形式\")&#125;) 案例： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0px; padding: 0px; &#125; div &#123; height: 200px; background: blueviolet; margin-bottom: 10px; &#125; &lt;/style&gt; &lt;script src=\"js/jquery-1.11.1.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; $(\"#demo\").click(function()&#123; $(\"div\").hide(1000) &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"我是按钮\" id=\"demo\"/&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Jquery详细介绍#$符号介绍#在js中的变量命名：下划线、字母、$、数字组成，但是不能以数字开头 在jquery中，它占用了我们js中的2个变量分别是：$ 和 jQuery 补充:模拟jquery的操作 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;模拟jquery&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; $=function(dom)&#123; return &#123; ready:function(func)&#123; // 判断一下 docuemnt.onload 有没有被赋值（或者说有没有这个事件） // 1.有：接收一个旧的函数，然后呢，我先去调用新的函数，接着再调用旧的函数 // 2.没有：直接赋值个onload事件 if(typeof dom.onload===\"function\")&#123; var oldFun=dom.onload; dom.onload=function()&#123; func(); oldFun(); &#125; &#125;else&#123; dom.onload=func; &#125; &#125; &#125; &#125; $(window).ready(function()&#123; alert(\"第一次调用\") &#125;) $(window).ready(function()&#123; alert(\"第二次调用\") &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; jquery入口函数# 1.Js的window.onload事件是等到所有内容，以及我们的外部图片之类的文件加载完了之后，才回去执行 2.jQuery的入口函数 是在 html所有标签都加载之后，就回去执行。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; alert(document.getElementsByTagName(\"img\")[2].clientWidth); &#125;; /*$(function () &#123; //alert(document.getElementsByTagName(\"img\")[2].clientWidth); alert($(\"#img3\").width()); &#125;);*/ &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"imgs/01.jpg\" alt=\"\"/&gt; &lt;img src=\"imgs/02.jpg\" alt=\"\"/&gt; &lt;img id=\"img3\" src=\"imgs/03.jpg\" alt=\"\"/&gt;&lt;/body&gt;&lt;/html&gt; Jquery中选择器（参考api）#基本选择器# 符号 说明 用法 $(“#demo”) 选择id为demo的第一个元素 $(“#demo”).css(“background”,”red”) $(“.liItem”) 选择所有类名（样式名）为liItem的元素 $(“.liItem”). css(“background”,”red”); $(“div”) 选择所有标签名字为div的元素 $(“div”). css(“background”,”red”); $(“*”) 选择所有元素 少用或配合其他选择器来使用 $(“*”). css(“background”,”red”) $(“.liItem,div”) 选择多个指定的元素，这个地方是选择出了 .liItem元素和div元素 $(“.liItem,div”). css(“background”,”red”) 层级选择器# 符号 说明 用法 空格 后代选择器 选择所有的后代元素 $(“div span”). css(“background”,”red”); &gt; 子代选择器 选择所有的子代元素 $(“div &gt; span”). css(“background”,”red”) + 紧邻选择器 选择紧挨着的下一个元素 $(“div + p”). css(“background”,”red”) ~ 兄弟选择器 选择后面的所有的兄弟元素 $(“div ~ p”). css(“background”,”red”) 过滤选择器# 符号 说明 用法 :eq(index) index是从0开始的一个数字，选择序号为index的元素。选择第一个匹配的元素。 $(“li:eq(1)”). css(“background”,”red”) :gt(index) Index 是从0开始的一个数字，选择序号大于index的元素 $(“li:gt(2)”). css(“background”,”red”) :lt(index) Index是从0开始的一个数字，选择小于index 的元素 $(“li:lt(2)”). css(“background”,”red”) :odd 选择所有序号为奇数行的元素 $(“li:odd”). css(“background”,”red”) :even 选择所有序号为偶数的元素 $(“li:even”). css(“background”,”red”) :first 选择匹配第一个元素 $(“li:first”). css(“background”,”red”) :last 选择匹配的最后一个元素 $(“li:last”). css(“background”,”red”) 属性选择器# 符号 说明 用法 $(“a[href]”) 选择所有包含href属性的元素 $(“a[href]”). css(“background”,”red”) $(“a[href=’hello’]”) 选择href属性值为hello的所有a标签 $(“a[href=’hello’]”). css(“background”,”red”) $(“a[href!=’baidu’]”) 选择所有href属性不等baidu的所有元素，包括没有href的元素 $(“a[href!=’baidu’]”). css(“background”,”red”) $(“a[href^=’web’]”) 选择所有以web开头的元素 $(“a[href^=’web’]”). css(“background”,”red”) $(“a[href\\$=’cn’]”) 选择所有以cn结尾的元素 $(“a[href$=’cn’]”). css(“background”,”red”)** $(“a[href*=’i’]”) 选择所有包含i这个字符的元素，可以是中英文 $(“a[href*=’i’]”). css(“background”,”red”) $(“a[href][title=’我’]”) 选择所有符合指定属性规则的元素，都符合才会被选中。 $(“a[href][title=’我’]”). css(“background”,”red”)","categories":[{"name":"jquery","slug":"jquery","permalink":"http://baofengketang.com/categories/jquery/"}],"tags":[{"name":"jquery基础","slug":"jquery基础","permalink":"http://baofengketang.com/tags/jquery基础/"}]},{"title":"Spring开发实战01","slug":"spring_anno/spring_anno_01","date":"2018-06-04T06:14:52.000Z","updated":"2018-06-05T03:48:50.000Z","comments":true,"path":"2018/06/04/spring_anno/spring_anno_01/","link":"","permalink":"http://baofengketang.com/2018/06/04/spring_anno/spring_anno_01/","excerpt":"","text":"Spring开发实战01#为什么要使用spring#代码耦合度太高#123public class EmployeeServiceImpl &#123; private IEmployeeDAO employeeDAO = new EmployeeDAOImpl();&#125; 现在如果要更换实现类，就必须更改源代码，代码的耦合度太高 对象的依赖关系比较繁琐#1234public class EmpployeeAction &#123; private IEmployeeService service; private IDepartmentService departmentService;&#125; 如果对象过多，并且互相存在以来关系，并且有的对象需要单例模式,有的则需要多实 事务控制繁琐#对于事务,可以使用Filter或是Struts2的拦截器实现,但这样有一些不好的地方: 1.此时事务开在表现层,事务周期太长。 2.有的action方法没有用到数据库操作,不需要开事务。 3.不能针对某个具体功方法配置事务是否是只读的,因为有的方法只是查询数据。 而正确的解决方案:把事务开启在 service 层是。但是: 每个方法前都要开启事务,每个方法后都要 关闭事务，代码臃肿,开发效率低下。 如何降低业务逻辑部分之间耦合度,提高程序的可重用性,同时提高开发的效率!Spring的aop机制可以帮助我们方便的帮助我们解决 12345678910111213package cn.org.kingdom.app;public class EmployerService &#123; public void save()&#123; //开启事务 //dao.save(...); //关闭事务 &#125; public void update()&#123; //开启事务 //dao.save(...); //关闭事务 &#125;&#125; Spring简介#Spring概述#Spring是一个轻量级的DI/IoC和AOP容器框架。存在的目的是用于构建轻量级的J2EE应用。Spring以一种非侵入式的方式来管理你的代码,Spring提倡”最少侵入”,这也就意味着你可以适当的时候安装或卸载Spring。 ◆目的:解决企业应用开发的复杂性 ◆功能:使用基本的JavaBean代替EJB,并提供了更多的企业应用功能 ◆范围:任何Java应用 简单来说:Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架 Spring课程中的常用术语#1、应用程序:是能完成我们所需要功能的成品,比如购物网站、OA系统。 2、框架:是能完成一定功能的半成品,比如我们可以使用框架进行购物网站开发;框架做一部分功能,我 们自己做一部分功能,这样应用程序就创建出来了。而且框架规定了你在开发应用程序时的整体架构,提 供了一些基础功能,还规定了类和对象的如何创建、如何协作等,从而简化我们开发,让我们专注于业务 逻辑开发。 3、非侵入式设计:从框架角度可以这样理解,无需继承框架提供的类,这种设计就可以看作是非侵入式设 计,如果继承了这些框架类,就是侵入设计,如果以后想更换框架之前写过的代码几乎无法重用,如果非 侵入式设计则之前写过的代码仍然可以继续使用。 4、轻量级及重量级:轻量级是相对于重量级而言的,轻量级一般就是非入侵性的、所依赖的东西非常少、 资源占用非常少、部署简单等等,其实就是比较容易使用,而重量级正好相反。 5、POJO:POJO(Plain Old Java Objects)简单的Java对象,它可以包含业务逻辑或持久化逻辑, 但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。 6、容器:在日常生活中容器就是一种盛放东西的器具,从程序设计角度看就是装对象的的对象,因为存在 放入、拿出等操作,所以容器还要管理对象的生命周期。 Spring的组织架构图# Spring的jar包分析#spring-framework-x.x.RELEASE:Spring 核心组件。 ​ docs: Spring 开发、帮助文档。 libs: Spring 核心组件的。jar 包、源代码、文档。 ​ schema: Spring 配置文件的 schema 约束文件。 spring-framework-x.x.RELEASE-dependencies:Spring 依赖的第三方组件。 包含了各大开源组织提供的依赖 jar。比如 apache common 下的:dbcp.jar pool.jar logging.jar Spring的优势#1.低侵入/低耦合(降低组件之间的耦合度,实现软件各层之间的解耦) 2.声明式事务管理 3.方便集成其他框架 4.降低JavaEE开发难度 5.Spring框架中包括JavaEE 三层的每一层的解决方案 (一站式)","categories":[{"name":"spring","slug":"spring","permalink":"http://baofengketang.com/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://baofengketang.com/tags/spring/"}]},{"title":"移动互联网","slug":"mobile/mobile01","date":"2018-05-29T08:08:57.000Z","updated":"2018-05-30T02:36:02.000Z","comments":true,"path":"2018/05/29/mobile/mobile01/","link":"","permalink":"http://baofengketang.com/2018/05/29/mobile/mobile01/","excerpt":"","text":"移动互联发展 概述 移动互联所涉及的技术领域 操作系统 微博等自媒体技术 二维码技术 HTML5技术 定位、导航、GPS位置跟踪技术 “云”技术， 语音、视频通讯技术 摇一摇 技术 移动支付：网购、预订、充值等。 语音识别、搜索。 中间件技术 移动互联的发展 得入口者得天下 移动端产品的急剧增多 移动互联发展#概述#最初接触移动互联网是在去年谷歌的一次android推介会，之前虽然也了解过，但对移动互联网的认识仅限于手机上网。也是那次之后我对移动互联网产生了莫大的兴趣，虽然还不太清楚到底什么才是真正的移动互联网。后来和一位搞投资的朋友讨论移动互联网，我本能的说最大的特点是移动，而朋友说是小。现在想想，朋友说的要高一筹，不过这两种说法本质是相同的。所谓的移动互联网，为什么要叫移动互联网，我是从字面和本质上理解的,而朋友是载体的特征上理解的。 不过自从使用智能机后，我对移动互联网有了新的理解，越来越觉得当年的移动和小太过肤浅。或许以后我对移动互联网还会有其他新的认识，但当下我却深刻的感觉的移动互联网是应用的天下。 在电脑上上网的时候，我们要上网就会直接打开浏览器，以前上qq要打开qq客户端，现在也可以直接打开webqq，以前总是把音乐和影视剧下载的硬盘里看，现在带宽越来越大，在线看和听完全没有任何不流畅的地方。可以说大多数跟网络相关的事都能通过浏览器来搞定，这才有了互联网入口之争。 而相对于移动互联网来说，想通过浏览器来上qq，首先就要考虑打开速度，我在公司只能使用1M的点心宽带，打开webqq都会加载半天，更何况手机，况且，再加上手机屏幕限制，webqq根本就没法在手机上用，只能用qq的几个移动客户端。像人人网、京东商城、新浪微博这样的网站在手机上打开总会有各种不便，有些脚本无法执行，如果没有专门的客户端，丢掉移动领域的市场将会是必然。像各种地图、导航软件，如果是通过手机浏览器打开，有些根本就看不到地图，更不用说导航了。这些也只能通过应用来体现。还有一些像手电筒、日历、闹钟、电子琴、收音机、录音机这类也只能通过应用来体现。更多手机上需要的功能，也都只能通过应用来体现出来。 诸如各种优惠券、团购券之类的互联网传统应用在移动互联网上有着无与伦比的优势，这部分也必然会出现大量移动互联网应用，另外还有星巴克新出的手机代码取餐之类的功能相对传统互联网有些绝对优势，未来这种应用也会越来越多。 移动互联所涉及的技术领域#对于移动互联所涉及的技术领域，我个人从开发这么多年的经验总结如下几个方面 操作系统#这些移动智能操作系统本身包含的技术很多，可以在这些平台基础上结合其他技术开发出各式各样的移动终端应用，进而在移动互联网的大潮中占住一席之地。 微博等自媒体技术#微博已经盛行很久，积累了数以亿计的用户量，很多人利用微博途径来推广相关的一些信息，起到了类似媒体宣传的效果。我们也可以借助微博大的用户量，用微博等账号作为我们app的登录账号，可免去用户注册之烦，同时还可直接将app相关信息分享到微博，进行一定地宣传。 二维码技术#二维码中可以包含文本、链接、图片等信息。广泛应用于：二维码产品推广（包含产品信息，免去用户通过上网搜索产品）、二维码防伪、二维码电子优惠券、二维码名片、二维码微博营销、二维码墓碑等等。 HTML5技术#通过HTML5和JavaScript可以开发移动Web应用，同时可以利用通过这几种途径将HTML5编写的内容转化成android应用： Android中的WebView控件 使用PhoneGap（它是基于HTML、CSS、JavaScript，创建移动跨平台应用的快速开发平台） 使用Rexsee在线生成android apk。Rexsee是开源的android开发平台，它支持开发以Web模式开发移动应用，所以说会HTML就会android 使用appMobi HTML5 XDK在线生成android应用 定位、导航、GPS位置跟踪技术#用的比较多的是百度map、Google map等开放的API来实现第三方应用的定位、导航等功能。可以有以下用途： a、定位目前所在位置，计算出发地与目的地之间的距离。 b、告诉用户从A到B怎么走，为用户出行导航。 c、移动物联网中可以通过GPS或者物品条形码知道物品所到达的位置。 “云”技术，#云推送、云备份、云下载、输入法的云联想、云盘等。“云”技术简单理解就是客户端通过网络与服务器（一般都是到达了一定数据量或者说数以万计、亿计的大数据量）相连获取与之相关的信息。用的比较多场合如下： a、推送：服务端向客户端主动下行内容，客户端接收到并提示用户，这一技术广泛用户移动应用中。 b、备份：将本地文件上传到服务器保存，让服务器为我们本地文件做一个备份。 c、下载：客户端与服务器相连，下载服务器端的文件内容。 语音、视频通讯技术#A与B进行语音、视频通讯的过程：A发送的语音、视频数据通过压缩算法进行压缩，然后通过app中定的通讯协议经网络把压缩后的语音、视频数据信息传给B，B接收到这些数据后，解压缩、将这些串起来还原成的语音、视频信息。如：应用中的语音、视频聊天等。 摇一摇 技术#智能机时代到来，智能机硬件都有重力加速感应模块，可以实现摇一摇手机通过网络从服务端获取所需的内容，例如：获取同一时刻摇手机的人、获取自己周围的人等。 移动支付：网购、预订、充值等。#用户、厂商、银行将客户端与银行卡相关联，通过一定协议和网络实现移动在线支付。例如：支付宝、酒店预订、高尔夫球场预订等。 语音识别、搜索。#客户端采集到用户发出的语音信息，经过一些信号处理等技术，发送到服务端，经服务端找出相匹配的信息返回给客户端。例如：科大讯飞的语音识别、语音阅读、微信的语音输入等。 中间件技术#将客户端不易适配的部分放在云端，客户端只要能接收到相关信息，就能做相应的适配，使客户端应用兼容性更高 移动互联的发展#2018移动互联网整体行业报告 得入口者得天下#移动互联网时代，得入口者得天下，入口是指用户寻找信息解决问题的方式，谁掌握了移动互联网入口，谁就掌握了联接用户的第一触点，好的入口可以带来源源不断的用户流、信息流、业务流、资金流和物流，从而将虚拟资本转化为商业价值。 想在手机搜索信息了，你第一时间想起了手机百度，它就是搜索的入口；想通过手机浏览网页了，你第一时间想起了QQ浏览器，它就是上网的入口；想购物消费了，你第一时间想起了手机淘宝，它就是娘们姐们妹们败家的入口，也有人说移动互联网时代得女人者得天下，还是有一定道理的，估计美女们平时的空余时间比较多，喜欢随时随地分享、交流、沟通，并且美女们对购物天生就有冲动，移动互联网产品最大化满足了美女们的空档时间和情感需要，所以美女用户在活跃度上远远高于男性用户，这是多么痛的领悟啊！。 我们很多人都喜欢显摆喜欢晒，于是微信成了我们精神的入口，不仅可以多种方式的沟通，最主要的是可以向朋友圈晒你的美食美景美事，然后点赞纷呈评论纷飞，你心里美滋滋的，那份满足感和幸福感让你开心好几天，更可怕的是现在有了美容入口，自拍神器美顔相机，你脸上的皱纹你眼角的眼袋你黝黑的肤色你黑色的眼圈你头上的头皮屑…….经这么三秒钟的磨皮美化全都变美变白了，美顔相机就是你年轻漂亮的入口，它不红都难。 移动端产品的急剧增多#据工信部数据显示，我国移动互联网用户总数达到8.72亿户，对移动电话用户的渗透率达到69.1%，月户均移动互联网接入流量达到178.8M。显而易见，很多大型互联网企业PC业务用户往移动端迁移，呈现出PC业务增长放缓，移动业务增长迅速的态势。如果一个互联网企业没有在移动端的拳头产品，将很快被移动互联网的浪潮颠覆，比如马云这几年是比较紧张的，挣扎着去做社交APP来往，不停地投资入口APP比如快的打车和拼车APP，当然后来做的手机支付宝及淘宝也是发展很快的，因为那是阿里的强项，但马云一定眼红腾讯的移动互联网产品，因为他知道在未来的日子里，得移动互联网者得天下。 移动互联网产品强调解决用户的痛点，创业者全心全力聚焦于一个痛点，然后专心专注专业地做到极致，一针捅破天，一招打遍天下，一首歌唱尽一辈子，那么，作为创业者我们在产品的策划及执行上应该怎么去思考和实施呢？最近阅读了朋友圈的一篇文章，很有感触，用自已的话来和大家分享一下四个启示： 1）以工具切入，通过刚需快速积累用户，这类产品市面上很多，比如美图、淘宝、社交、婚恋、新闻等诸如此类的。社会的刚需是很多的，但做刚需产品是漫长煎熬的，通常拥有资源及数据者比较容易成功，比如我是航空公司的，我做航班信息及相关创新的APP，是拥有绝对的优势的，再比如腾讯QQ已拥有大量的PC用户，再做什么创新产品如微信都是较容易成功的，当然个人创业者也可以成功，那么你就要有更大的创新更强的专注，我个人认为未来几年一定会有新型的社交产品出现，它会超过微信陌陌之类的，但它是什么呢？谁知道呢。 2）深耕垂直领域，提高商业价值；现在都喜欢讲产业链垂直整合，那究竟什么是产业链垂直整合，简单地说就是其产业链上下（游）的整合，产业链通常包括产品设计、原材料采购、订单处理、生产制造、仓储物流、批发经营、终端零售7个环节,所谓产业链垂直整合，就是把这7个环节垂直整合起来，使得整条产业链高效运转。比如航空公司越来越多地执行过去由旅行社扮演的角色，就是典型的向前整合。同样，航空公司亦亲力而为供应商的角色如飞机维护、飞行餐饮，就是典型的向后整合。创业者选择自已NB的行业是相当重要的，你熟悉和理解这个行业的需求及用户痛点，你要做的只是平台化和移动化，将产业链串连起来融合起来，即使你的平台和APP都是免费的，但没有关系，整合过程中会发现越来越多的商业模式，越靠近最终用户和消费者的公司，在产业链拥有越来越大的发言权。 3）反向定义，重构产业链条牢牢卡位。这一条我没有什么好扩展的了，也好容易理解。 4）引入社区，增加活跃度和黏性。这个重要，社区概念，任何的平台或APP最好都引入社区功能，让用户之间可以分享和互动，做企业级服务平台的，就搞个企业社区，让企业之间员工之间有互动交流的功能，可成立各种各样的圈子，线上互动线下行动，八小时内是工作和业务，八小时外是生活和娱乐，工作和生活之间可以快速切换，任何人都有社交和被社交的需求，工作上你需要成长和提升，生活上你需要朋友和温暖。","categories":[{"name":"移动互联","slug":"移动互联","permalink":"http://baofengketang.com/categories/移动互联/"}],"tags":[{"name":"移动互联","slug":"移动互联","permalink":"http://baofengketang.com/tags/移动互联/"}]},{"title":"Java8学习笔记（二）","slug":"java/java02","date":"2018-05-29T02:37:16.000Z","updated":"2018-05-31T13:49:32.000Z","comments":true,"path":"2018/05/29/java/java02/","link":"","permalink":"http://baofengketang.com/2018/05/29/java/java02/","excerpt":"","text":"Java8学习笔记（二）#JDK8对接口增加了新的定义#增加了默认方法 增加了静态方法 类型推断机制#对于lambda表达式，必须要有其上下文，才能推断其类型 12","categories":[{"name":"java","slug":"java","permalink":"http://baofengketang.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://baofengketang.com/tags/java/"}]},{"title":"redis实战","slug":"redis/redis_01","date":"2018-05-17T05:28:32.000Z","updated":"2018-05-31T13:49:14.000Z","comments":true,"path":"2018/05/17/redis/redis_01/","link":"","permalink":"http://baofengketang.com/2018/05/17/redis/redis_01/","excerpt":"","text":"Redis实战#NoSql介绍#NoSQL 是 Not Only SQL 的缩写，意即”不仅仅是SQL”的意思，泛指非关系型的数据库。强调Key-Value Stores和文档数据库的优点，而不是单纯的反对RDBMS。 NoSQL产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能NoSQL产品 redis、mongodb Membase、HBase Redis简介#什么是Redis#Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis应用场景#主要能够体现 解决数据库的访问压力。 例如:短信验证码时间有效期、session共享解决方案 Redis优势#性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis与其他key-value存储有什么不同#Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。 Redis安装#window下安装#点击这里进行下载redis 选择相应的版本，然后直接解压即可 文件介绍 12345678910111213文件介绍：redis-benchmark.exe #基准测试redis-check-aof.exe # aofredischeck-dump.exe # dumpredis-cli.exe # 客户端redis-server.exe # 服务器redis.windows.conf # 配置文件 建立一个启动文件start.bat 1redis-server.exe redis.windows.conf 启动服务器 mac下安装redis#欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"redis","slug":"redis","permalink":"http://baofengketang.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://baofengketang.com/tags/redis/"}]},{"title":"使用hexo搭建个人博客","slug":"hexo/hexo_02","date":"2018-05-13T15:32:44.000Z","updated":"2018-05-31T13:44:55.000Z","comments":true,"path":"2018/05/13/hexo/hexo_02/","link":"","permalink":"http://baofengketang.com/2018/05/13/hexo/hexo_02/","excerpt":"","text":"安装主题#安装NexT，在其文件夹中鼠标右键，点击Git Base Here。输入命令：git clone https://github.com/iissnan/hexo-theme-next themes/next 123456C:\\blog&gt;git clone https://github.com/theme-next/hexo-theme-next themes/nextCloning into 'themes/next'...remote: Counting objects: 3495, done.remote: Compressing objects: 100% (52/52), done.remote: Total 3495 (delta 32), reused 0 (delta 0), pack-reused 3443Receiving objects: 99% (3461/3495), 1020.01 KiB | 62Receiving objects: 100% (3495/3495), 1.21 MiB | 667.00 KiB/s, done. 启用主题#启用主题，在站点目录中（blog），打开配置文件_config.yml，修改theme：next 1234567theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/njwangbohz/njwangbohz.github.io.git branch: master 主题设定#在next主题目录下的_config.yml文件中将scheme设定为Pisces 12345# Schemesscheme: Pisces#scheme: Mist#scheme: Pisces#scheme: Gemini 语言设定#在站点根目录下修改配置文件_cofig.yml中的language为zh-Hans（简体中文） 1234567title: Hexosubtitle:description:keywords:author: John Doelanguage: zh-Hanstimezone: 修改菜单项#在主题目录下修改配置文件_cofig.yml中的menu（注：千万不要在这设置中文，后面的值那是查找文件的地方！若你的站点运行在子目录中，请将链接前缀的 / 去掉） 1234567menu: home: / about: /about tags: /tags categories: /categories archives: /archives search: /search 这些配置都要与你主题目录下的languages文件中对应的yml文档里配置相关联。比如你在站点根目录中的配置文件设置language为zh-Hans，那么就要进入到主题目录下的languages文件中修改zh-Hans.yml，这样才能显示出菜单项新增的中文内容 123456789101112131415---title: archive: 归档 category: 分类 tag: 标签 schedule: 日程表menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 设置侧栏位置#修改主题目录下sidebar的position值 12345678910sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: right #position: right # Sidebar Display, available value (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. 设置头像#在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下） 12#博客的头像设置avatar: http://p6wdo7p1v.bkt.clouddn.com/favicon.ico 设置代码主题#在主题目录下修改配置文件highlight_theme，默认值为nomal。可以设置为night 1234# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties 创建相关子页面#12345about: /about tags: /tags categories: /categories archives: /archives search: /search 子页面的路径在C:\\blog\\source_posts下创建 1234567891011C:\\blog\\source\\_posts&gt;hexo new page tagsINFO Created: C:\\blog\\source\\tags\\index.mdC:\\blog\\source\\_posts&gt;hexo new page categoriesINFO Created: C:\\blog\\source\\categories\\index.mdC:\\blog\\source\\_posts&gt;hexo new page archivesINFO Created: C:\\blog\\source\\archives\\index.mdC:\\blog\\source\\_posts&gt;hexo new page searchINFO Created: C:\\blog\\source\\search\\index.md 在tag\\index.md文件中添加以下内容 12345---title: tagsdate: 2018-05-14 22:25:00type: &quot;tags&quot;--- 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可，如： 123456---title: Hello Worlddate: 2018-1-1tags: [hexo,git,nmp]categories: 博客--- 首页添加github导航(可选)#在首页添加github导航条，点击https://blog.github.com/2008-12-19-github-ribbons/选择需要的样式，然后将代码复制到themes/next/layout/_layout.swig.并将href改为你的github地址 12&lt;a href=&quot;https://njwangbohz.github.io/&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png&quot; alt=&quot;Fork me on GitHub&quot;&gt;&lt;/a&gt; &lt;header id=&quot;header&quot; class=&quot;header&quot; itemscope itemtype=&quot;http://schema.org/WPHeader&quot;&gt; 实现点击出现桃心效果#实现点击出现桃心效果，点击http://7u2ss1.com1.z0.glb.clouddn.com/love.js将代码copy到/themes/next/source/js/src里面新建的love.js中，然后打开\\themes\\next\\layout\\_layout.swig文件,在末尾（在前面引用会出现找不到的bug） ，引用love.js 修改头像并旋转#打开\\themes\\next\\source\\css_common\\components\\sidebar\\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 加入卜算子统计#在网站底部加上访问量，打开\\themes\\next\\layout_partials\\footer.swig文件,在类copyright前加上画红线这话： 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"hexo","slug":"hexo","permalink":"http://baofengketang.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://baofengketang.com/tags/hexo/"}]},{"title":"使用hexo搭建个人博客","slug":"hexo/hexo_01","date":"2018-05-13T08:19:23.000Z","updated":"2018-05-31T13:44:46.000Z","comments":true,"path":"2018/05/13/hexo/hexo_01/","link":"","permalink":"http://baofengketang.com/2018/05/13/hexo/hexo_01/","excerpt":"","text":"使用Hexo搭建属于自己的博客#因最近有很多小伙伴咨询我如何写一个自己的博客，因为我的博客是采用mac系统搭建的，大部分小伙伴用的是window，因此本套教程我使用虚拟机上模拟window的环境搭建而成 1.安装nodejs环境#首先安装nodejs，我下载的版本是node-v8.11.1-x64，这个步骤就直接next就可以 检测环境是否安装成功 1234C:\\Users\\jinzhong&gt;node -vv8.11.1C:\\Users\\jinzhong&gt;npm -v5.6.0 如果出现以上提示就表示环境搭建完毕 2.安装git环境#git版本：Git-2.17.0-64-bit 接下来开始安装.基本上一路next即可 检测环境 12$ git --versiongit version 2.17.0.windows.1 3.github设置#1.注册好了github后，进入github官网 2.新建仓库 3.设置仓库 发现页面已经部署到服务器了，我们可以直接访问http://njwangbohz.github.io 我们也可以选择一个主题，然后从新浏览 至此git目前就搭建完毕了～，后期我们可以继续加一些其它设置 4.安装hexo#安装Hexo，随便在某个目录创建一个文件夹 123456789101112131415161718C:\\&gt;mkdir blogC:\\&gt;cd blogC:\\blog&gt;npm install hexo -gnpm WARN deprecated titlecase@1.1.2: no longer maintainedC:\\Users\\jinzhong\\AppData\\Roaming\\npm\\hexo -&gt; C:\\Users\\jinzhong\\AppData\\Roaming\\npm\\node_modules\\hexo\\bin\\hexo&gt; nunjucks@3.1.2 postinstall C:\\Users\\jinzhong\\AppData\\Roaming\\npm\\node_modules\\hexo\\node_modules\\nunjucks&gt; node postinstall-build.js srcnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.3 (node_modules\\hexo\\node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.3: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)+ hexo@3.7.1added 205 packages in 1230.836s 输入hexo －v检查hexo是否安装成功 1234567891011121314151617C:\\blog&gt;hexo -vhexo-cli: 1.1.0os: Windows_NT 6.1.7601 win32 x64http_parser: 2.8.0node: 8.11.1v8: 6.2.414.50uv: 1.19.1zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2oicu: 60.1unicode: 10.0cldr: 32.0tz: 2017c 输入hexo init进行初始化 1234567891011121314151617181920212223242526272829C:\\blog&gt;hexo initINFO Cloning hexo-starter to C:\\blogCloning into 'C:\\blog'...remote: Counting objects: 65, done.remote: Compressing objects: 100% (3/3), done.remote: Total 65 (delta 0), reused 0 (delta 0), pack-reused 62Unpacking objects: 100% (65/65), done.Submodule 'themes/landscape' (https://github.com/hexojs/hexo-theme-landscape.git) registered for path 'themes/landscape'Cloning into 'C:/blog/themes/landscape'...remote: Counting objects: 819, done.remote: Total 819 (delta 0), reused 0 (delta 0), pack-reused 819Receiving objects: 100% (819/819), 2.54 MiB | 819.00 KiB/s, done.Resolving deltas: 100% (432/432), done.Submodule path 'themes/landscape': checked out '73a23c51f8487cfcd7c6deec96ccc7543960d350'INFO Install dependencies��Ϣ: ���ṩ��ģʽ�޷��ҵ��ļ�npm WARN deprecated titlecase@1.1.2: no longer maintained&gt; nunjucks@3.1.2 postinstall C:\\blog\\node_modules\\nunjucks&gt; node postinstall-build.js srcnpm notice created a lockfile as package-lock.json. You should commit this file.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.3 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.3: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)added 276 packages in 206.107sINFO Start blogging with Hexo! 输入npm install 安装所需要的组件 1234C:\\blog&gt;npm installnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.3 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.3: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;) 接下来就可以体验一下hexo,启动服务 123C:\\blog&gt;hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 使用浏览器访问 5.hexo与github联系起来 配置git的用户名和密码 1234jinzhong@WIN-Q673GTLFDM6 MINGW64 /c/blog$ git config --global user.name e \"njwangbohz\"jinzhong@WIN-Q673GTLFDM6 MINGW64 /c/blog$ git config --global user.email \"15189838151@163.com\" 生成..ssh 12345678910111213141516171819202122 ssh-keygen -t rsa -C \"15189838151@163.COM\"Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/jinzhong/.ssh/id_rsa):Created directory '/c/Users/jinzhong/.ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/jinzhong/.ssh/id_rsa.Your public key has been saved in /c/Users/jinzhong/.ssh/id_rsa.pub.The key fingerprint is:SHA256:gkcWg2JUUOvQqfIIUqX60WZxBzjK51uxDrIpQwINNbE 15189838151@163.COMThe key's randomart image is:+---[RSA 2048]----+| o*=+o+ ||. o*+o + || =Eo=.+ . ||.o+=.*.. ||* oo* ooS ||+*.+o.o. ||+ o+ = ||o o . . || o |+----[SHA256]-----+ 进入.ssh目录,查看key文件 123jinzhong@WIN-Q673GTLFDM6 MINGW64 ~/.ssh$ cat id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCspC2HQMc7wTlzeCib7m0rzAuihSjDozR6sL0B4H7APyWTTQ3HWgUO7zRNCMFmLA5QYBzzsr4EBaGskMQa8Olktcj2iG62QQ06wzdYiFBVzOCDsbPaHwIL52O9+BiMzjC5VTfD18acASJh/qXBgkEjA1YJ9pnhk0hMHf5N/j4CoiB4guhTMyezRh5lMpfhBE9uq0UFVXGdBjmu0l/gj/UVCeWP/CFSfYo070ii50k6IMn+pE3OkQYB/36yEycu4vQp0HTfgPAD6qp2s3QRfwuS/jzSrbyhWbBs7YuTyVREdCVKUxhqcm+/+AceV520cCpftz1yHe2dm/JpJ4AjydlL 15189838151@163.COM 将这个key添加到git中 测试 123456$ ssh -T git@github.comThe authenticity of host 'github.com (52.74.223.119)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com,52.74.223.119' (RSA) to the list of known hosts.Hi njwangbohz! You've successfully authenticated, but GitHub does not provide shell access. 配置blog目录下的_config.xml文件 1234deploy: type: git repo: https://github.com/njwangbohz/njwangbohz.github.io.git branch: master 安装插件并发布到git 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990C:\\blog&gt;npm install --save hexo-deployer-gitnpm WARN deprecated swig@1.4.2: This package is no longer maintainednpm WARN notice [SECURITY] uglify-js has 1 low vulnerability. Go here for more details: https://nodesecurity.io/advisories?search=uglify-js&amp;version=2.4.24 - Run `npm i npm@latest -g` to upgrade your npm version, and then `npm audit` to getmore info.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.3 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.3: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)+ hexo-deployer-git@0.3.1added 32 packages in 171.121sC:\\blog&gt;hexo dINFO Deploying: gitINFO Setting up Git deployment...Initialized empty Git repository in C:/blog/.deploy_git/.git/[master (root-commit) 86378a6] First commit 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 placeholderINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...warning: LF will be replaced by CRLF in 2018/05/13/hello-world/index.html.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in archives/2018/05/index.html.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in archives/2018/index.html.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in archives/index.html.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in css/style.css.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/helpers/jquery.fancybox-buttons.css.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/helpers/jquery.fancybox-buttons.js.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/helpers/jquery.fancybox-media.js.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/helpers/jquery.fancybox-thumbs.css.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/helpers/jquery.fancybox-thumbs.js.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/jquery.fancybox.css.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/jquery.fancybox.js.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/jquery.fancybox.pack.js.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in index.html.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in js/script.js.The file will have its original line endings in your working directory.[master e16eabb] Site updated: 2018-05-13 23:14:34 29 files changed, 5777 insertions(+) create mode 100644 2018/05/13/hello-world/index.html create mode 100644 archives/2018/05/index.html create mode 100644 archives/2018/index.html create mode 100644 archives/index.html create mode 100644 css/fonts/FontAwesome.otf create mode 100644 css/fonts/fontawesome-webfont.eot create mode 100644 css/fonts/fontawesome-webfont.svg create mode 100644 css/fonts/fontawesome-webfont.ttf create mode 100644 css/fonts/fontawesome-webfont.woff create mode 100644 css/images/banner.jpg create mode 100644 css/style.css create mode 100644 fancybox/blank.gif create mode 100644 fancybox/fancybox_loading.gif create mode 100644 fancybox/fancybox_loading@2x.gif create mode 100644 fancybox/fancybox_overlay.png create mode 100644 fancybox/fancybox_sprite.png create mode 100644 fancybox/fancybox_sprite@2x.png create mode 100644 fancybox/helpers/fancybox_buttons.png create mode 100644 fancybox/helpers/jquery.fancybox-buttons.css create mode 100644 fancybox/helpers/jquery.fancybox-buttons.js create mode 100644 fancybox/helpers/jquery.fancybox-media.js create mode 100644 fancybox/helpers/jquery.fancybox-thumbs.css create mode 100644 fancybox/helpers/jquery.fancybox-thumbs.js create mode 100644 fancybox/jquery.fancybox.css create mode 100644 fancybox/jquery.fancybox.js create mode 100644 fancybox/jquery.fancybox.pack.js create mode 100644 index.html create mode 100644 js/script.js delete mode 100644 placeholderUsername for 'https://github.com': 15189838151@163.comPassword for 'https://15189838151@163.com@github.com':Branch 'master' set up to track remote branch 'master' from 'https://github.com/njwangbohz/njwangbohz.github.io.git'.To https://github.com/njwangbohz/njwangbohz.github.io.git + 50f63d0...e16eabb HEAD -&gt; master (forced update)INFO Deploy done: gitC:\\blog&gt; 访问： 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"hexo","slug":"hexo","permalink":"http://baofengketang.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://baofengketang.com/tags/hexo/"}]},{"title":"Python基础(十三)","slug":"python_base/python_13","date":"2018-05-13T03:52:56.000Z","updated":"2018-05-31T13:49:17.000Z","comments":true,"path":"2018/05/13/python_base/python_13/","link":"","permalink":"http://baofengketang.com/2018/05/13/python_base/python_13/","excerpt":"","text":"给程序传递参数 列表推导式 Set集合 给程序传递参数#12import sysprint(sys.argv) 执行 123jinzhongdeMacBook-Pro:~ jinzhong$ python3 hello.py 1,2,3,4,5helloworld[&apos;hello.py&apos;, &apos;1,2,3,4,5&apos;] 列表推导式#所谓的列表推导式，指的就是轻量级循环创建列表 基本方式 1234567891011In [14]: a= [x for x in range(5)]In [15]: aOut[15]: [0, 1, 2, 3, 4]In [16]: a=[x for x in range(3,4)]In [17]: aIn [19]: a=[x for x in range(2,20)]In [20]: aOut[20]: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]In [21]: a=[x for x in range(2,20,2)]In [22]: aOut[22]: [2, 4, 6, 8, 10, 12, 14, 16, 18] 循环中使用if 123In [28]: a=[x for x in range(2,20) if x%2==0]In [29]: aOut[29]: [2, 4, 6, 8, 10, 12, 14, 16, 18] 2个for循环及多个循环 1234567891011121314151617181920In [32]: a=[(x,y) for x in range(1,3) for y in range(3)]In [33]: aOut[33]: [(1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]In [36]: a=[(x,y,z) for x in range(1,3) for y in range(3,5) for z in range(5,8)] ...:In [37]: aOut[37]:[(1, 3, 5), (1, 3, 6), (1, 3, 7), (1, 4, 5), (1, 4, 6), (1, 4, 7), (2, 3, 5), (2, 3, 6), (2, 3, 7), (2, 4, 5), (2, 4, 6), (2, 4, 7)] Set集合#set集合 12345678910111213141516171819202122232425In [1]: a=set()In [2]: type(a)Out[2]: setIn [3]: b=[1,2,3,12,3,1,3]In [4]: bOut[4]: [1, 2, 3, 12, 3, 1, 3]In [5]: c=set(b)In [6]: type(c)Out[6]: setIn [7]: cOut[7]: &#123;1, 2, 3, 12&#125;In [8]: d=list(c)In [9]: dOut[9]: [1, 2, 3, 12]In [10]: type(d)Out[10]: list 互相转换 1234567891011121314151617In [13]: dOut[13]: [1, 2, 3, 12]In [14]: e=tuple(d)In [15]: eOut[15]: (1, 2, 3, 12)In [16]: f =list(e)In [17]: fOut[17]: [1, 2, 3, 12]In [18]: g=set(e)In [19]: gOut[19]: &#123;1, 2, 3, 12&#125; 使用set可以快速的完成对list中的元素的去重复操作 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"爬虫实践－爬取51job岗位","slug":"python_data/python_data_06","date":"2018-05-10T14:54:03.000Z","updated":"2018-05-31T13:48:36.000Z","comments":true,"path":"2018/05/10/python_data/python_data_06/","link":"","permalink":"http://baofengketang.com/2018/05/10/python_data/python_data_06/","excerpt":"","text":"爬虫实践－爬取51job岗位#分析-基本元素爬取#打开网站 我们现在要获取到职位、公司、工作地点、薪资，发布时间这里的数据，通过审查元素来观察一下 有了这些规则，那么我们就可以通过爬虫来进行数据的爬取操作了 首先我们来爬取本页的第一条数据 12345678910111213141516171819#encoding=\"UTF-8\"import requestsfrom bs4 import BeautifulSoupheaders=&#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:59.0) Gecko/20100101 Firefox/59.0\"&#125;url=\"https://search.51job.com/list/070200,000000,0000,00,9,99,java,2,1.html?lang=c&amp;stype=1&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare=\"count=0;res=requests.get(url,headers=headers)res.encoding=\"gb2312\"soup = BeautifulSoup(res.text,\"html.parser\");soup.prettify()titles=soup.select(\"span.t1,p.t1 span\")company = soup.select(\"span.t2\")address = soup.select(\".dw_table span.t3\")sal= soup.select(\"span.t4\")publishTime=soup.select(\"span.t5\")i=1print(titles[i].text.strip(),company[i].text.strip(),address[i].text.strip(),sal[i].text.strip(),publishTime[i].text.strip()); 运行结果 1Hadoop开发工程师 南京森根科技发展有限公司 南京 1-2万/月 05-13 分析-动态爬取#好了，有了第一条数据之后，我们下面来增加动态的操作，用来爬取每页的所有数据，先观察一共多少页，以及页面的地址的变化 点击第二页，观察页面地址 同时我们也猜测了一下，如果将上图中的java换成python试试看页面的运行结果是什么 那么接下来我们就可以通过参数拼接的方式来进行动态爬取了 123456789101112131415161718192021222324#encoding=\"UTF-8\"import requestsfrom bs4 import BeautifulSoupheaders=&#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:59.0) Gecko/20100101 Firefox/59.0\"&#125;url=\"https://search.51job.com/list/070200,000000,0000,00,9,99,java,2,1.html?lang=c&amp;stype=1&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare=\"count=0;keywords=\"java\"for j in range(1,91): res=requests.get(\"https://search.51job.com/list/070200,000000,0000,00,9,99,\"+keywords+\",2,\"+str(j)+\".html?lang=c&amp;stype=1&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare=\",headers=headers) res.encoding=\"gb2312\" soup = BeautifulSoup(res.text,\"html.parser\"); soup.prettify() titles=soup.select(\"span.t1,p.t1 span\") company = soup.select(\"span.t2\") address = soup.select(\".dw_table span.t3\") sal= soup.select(\"span.t4\") publishTime=soup.select(\"span.t5\") i=1 while i&lt;len(titles): print(titles[i].text.strip(),company[i].text.strip(),address[i].text.strip(),sal[i].text.strip(),publishTime[i].text.strip()); i = i + 1print(count) 运行结果就不展示了，数据量太大 保存数据#之前我们都是将数据保存在文本中的，那么如果我想讲数据保存到数据库中怎么办呢？这里以mysql数据库为例 首先我们得通过pip安装mysqlclient库 1pip install mysqlclient 安装完毕后，就可以使用mysql来进行保存数据了，关于mysql的具体操作，这里就不做详细介绍了 123456789101112131415161718192021222324252627282930313233343536#encoding=\"UTF-8\"import requestsfrom bs4 import BeautifulSoup#引入mysql数据库import MySQLdbheaders=&#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:59.0) Gecko/20100101 Firefox/59.0\"&#125;url=\"https://search.51job.com/list/070200,000000,0000,00,9,99,java,2,1.html?lang=c&amp;stype=1&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare=\"count=0;keywords=\"java\"#获取mysql的链接conn=MySQLdb.connect(\"localhost\",port=3306,user=\"root\",password=\"root\",db=\"mytest\",charset=\"utf8\")print(conn)for j in range(1,90): res=requests.get(\"https://search.51job.com/list/070200,000000,0000,00,9,99,\"+keywords+\",2,\"+str(j)+\".html?lang=c&amp;stype=1&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare=\",headers=headers) res.encoding=\"gb2312\" soup = BeautifulSoup(res.text,\"html.parser\"); soup.prettify() titles=soup.select(\"span.t1,p.t1 span\") company = soup.select(\"span.t2\") address = soup.select(\".dw_table span.t3\") sal= soup.select(\"span.t4\") publishTime=soup.select(\"span.t5\") i=1 while i&lt;len(titles): print(titles[i].text.strip(),company[i].text.strip(),address[i].text.strip(),sal[i].text.strip(),publishTime[i].text.strip()); count+=1 cursor=conn.cursor() #执行游标 cursor.execute(\"insert into jobs(title,company,address,sal,pub_time) values (%s,%s,%s,%s,%s)\",(titles[i].text.strip(),company[i].text.strip(),address[i].text.strip(),sal[i].text.strip(),publishTime[i].text.strip())) i = i + 1#关闭资源conn.commit()cursor.close()conn.close() 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://baofengketang.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://baofengketang.com/tags/爬虫/"}]},{"title":"Python爬虫实践－今日头条（获取js动态内容）","slug":"python_data/python_data_05","date":"2018-05-10T08:03:34.000Z","updated":"2018-05-31T13:49:15.000Z","comments":true,"path":"2018/05/10/python_data/python_data_05/","link":"","permalink":"http://baofengketang.com/2018/05/10/python_data/python_data_05/","excerpt":"","text":"Python爬虫实践－今日头条 需求分析 爬取今日头条 Python爬虫实践－今日头条#需求分析# 通过审查元素我们发现页面内容基本上都是js生成而来的，我们在浏览器上看到，但是html源码中缺发现不了 对于这种情况我们应该如何进行爬取呢 方式一:从网页响应中找到js脚本返回的json数据 方式二:使用Selenium对网页进行模拟访问 这里我们采用第一种方式 爬取今日头条#即使网页内容是由 JS 动态生成加载的,JS 也需要对某个接口进行调用,并根据接口返回 的 JSON 数据再进行加载和渲染。所以我们可以找到 JS 调用的数据接口,从数据接口中找 到网页中最后呈现的数据。就以今日头条为例来演示: 找到js请求的数据接口 这里我们就采用python来爬去该网站的图片轮播图这块的数据 1234567891011import requestsfrom bs4 import BeautifulSoupimport jsonurl=\"https://www.toutiao.com/api/pc/focus/\"data=requests.get(url).textmyjsons=json.loads(data)titles=myjsons[\"data\"][\"pc_feed_focus\"]for temp in titles: title= temp.get(\"title\") image_url=temp.get(\"image_url\")[2:] print(\"标题:\",title,\"图片链接：\",image_url) 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://baofengketang.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://baofengketang.com/tags/爬虫/"}]},{"title":"Python网络爬虫实践－腾讯新闻","slug":"python_data/python_data_04","date":"2018-05-10T03:36:41.000Z","updated":"2018-05-31T13:49:15.000Z","comments":true,"path":"2018/05/10/python_data/python_data_04/","link":"","permalink":"http://baofengketang.com/2018/05/10/python_data/python_data_04/","excerpt":"","text":"爬虫实践－腾讯新闻 网站分析 定制请求头 传递url参数 发送POST请求 超时 获取响应的内容 开始爬取数据 爬虫实践－腾讯新闻#网站分析#打开腾讯新闻：http://news.qq.com/ 定制请求头#观察一下该网站的请求头 请求头Headers提供了关于请求、响应或者其它发送实体的信息，对于爬虫而言，请求头十分重要，如果没有请求头或者请求头和实际网页不一致，就可能无法返回正确的结果 Request并不会基于定制的请求头Header的具体情况改变自己的行为，只是在最后的请求中，所有的请求头信息都会被传递进去 123headers=&#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:59.0) Gecko/20100101 Firefox/59.0\"&#125; 传递url参数#为了请求特定的数据，我们需要在URL的查询字符串中加入某些数据，如果你是自己构建的url，那么数据一般会跟在一个问好后面，并且以键/值的形式放在URL中,比如 url?key1=value1 在Request中，我们可以将这些参数保存在字典中，用params构建至url中,例如传递key1＝value1和key2=value2 到url上可以这么编写 12345678import requestsheaders=&#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:59.0) Gecko/20100101 Firefox/59.0\"&#125;key_dict=&#123;\"key1\":\"value1\",\"key2\":\"value2\"&#125;url=\"http://news.qq.com/\"r=requests.get(url,headers=headers,params=key_dict)print(\"响应状态码\",r.status_code) 发送POST请求#除了发送get请求外，有时候还需要发送一些编码为表单形式的数据，比如登陆的时候为POST,因为如果使用GET请求，密码显示在URL上，这是非常不安全的，如果实现post请求，只需要简单的传递一个字典给Requests中的data参数，这个字典就会在发出请求的时候自动编码为表单形式 12345678import requestsheaders=&#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:59.0) Gecko/20100101 Firefox/59.0\"&#125;key_dict=&#123;\"key1\":\"value1\",\"key2\":\"value2\"&#125;url=\"http://news.qq.com/\"r=requests.post(url,headers=headers,data=key_dict)print(\"响应状态码\",r.status_code) 超时#有的时候爬虫会遇到服务器长时间不返回，这个时候爬虫就会一直等待，造成爬虫没有顺利的进行，因此可以在requests的timeout参数设定的秒数结束之后停止等待响应，意思就是，服务器在timeout秒内没有应答，就返回异常 12345678import requestsheaders=&#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:59.0) Gecko/20100101 Firefox/59.0\"&#125;key_dict=&#123;\"key1\":\"value1\",\"key2\":\"value2\"&#125;url=\"https://movie.douban.com/top250\"r=requests.get(url,headers=headers,timeout=0.001)print(\"响应状态码\",r.status_code) 运行时报错 1requests.exceptions.ConnectTimeout: HTTPSConnectionPool(host=&apos;news.qq.com&apos;, port=443): Max retries exceeded with url: /top250 (Caused by ConnectTimeoutError(&lt;urllib3.connection.VerifiedHTTPSConnection object at 0x1086c3080&gt;, &apos;Connection to movie.douban.com timed out. (connect timeout=0.001)&apos;)) 一般情况我们将这个值设置为20秒 获取响应的内容# 在request中，最常用的功能就是获取某个网页的内容 r=requests.get(“url”)：方法返回一个response对象 通过这个response对象我们可以获取我们想要的信息 r.text:是服务器响应的内容，会自动根据响应头部的字符编码进行解码 r.encoding:是服务器内容使用的文本编码 r.status_code:用于监测响应的状态码，如200，404等 r.content:是字节码的响应体，会自动解码gzip和deflate编码的数据 r.json():是requests中内置的josn解码器 开始爬取数据#我们需要爬取这个页面的每个新闻的标题，鼠标右击一条新闻标题，选择“审查元素” 在次审查一下另外一个元素 发现有共性，接下来我们就可以采用爬虫来进行爬取我们需要的标题与链接内容了 1234567891011121314151617181920212223#encoding=UTF-8import requestsfrom bs4 import BeautifulSoupheaders=&#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:59.0) Gecko/20100101 Firefox/59.0\"&#125;url = \"http://news.qq.com\"r=requests.get(url,headers=headers)data = r.textsoup =BeautifulSoup(data,\"html.parser\")news=soup.select(\"div.text em.l24 a.linkto\")f=open(\"news.txt\",\"w\")for n in news: title=n.get_text(); link=n.get(\"href\") data=&#123; \"标题\":title, \"链接\":link &#125; print(data) f.write(\"%s:%s\"%(title,link)+\"\\n\")f.close() 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://baofengketang.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://baofengketang.com/tags/爬虫/"}]},{"title":"Python爬虫入门","slug":"python_data/python_data_03","date":"2018-05-10T01:32:32.000Z","updated":"2018-05-31T13:49:16.000Z","comments":true,"path":"2018/05/10/python_data/python_data_03/","link":"","permalink":"http://baofengketang.com/2018/05/10/python_data/python_data_03/","excerpt":"","text":"Python爬虫入门 Http请求 Http的基本概念 HTTP概览 Http请求头 编写第一个简单的爬虫 第一步：获取页面 第二步：获取需要的数据 第三步：存储数据 Python爬虫入门#Http请求#无论我们通过浏览器打开网站、访问网页,还是通过脚本对 URL 网址进行访问,本质上都 是对HTTP服务器的请求,浏览器上所呈现的、控制台所显示的都是HTTP服务器对我们请求的响应。 以打开我的博客为例,我们在地址栏输入“www.baofengketang.com”,浏览器上呈现的是下图 进入到开发者模式 响应的源代码如下 Http的基本概念#通常 HTTP 消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行,一个或者多个头域,一个指示头域结束的空行和可选的消息体组成 HTTP概览#Request URl:表示请求的 URL Request Method:表示请求的方法,此处为 GET。除此之外,HTTP 的请求方法还有 OPTION、 HEAD、POST、DELETE、PUT 等,而最常用的就是 GET 和 POST 方法: POST 向指定资源提交数据,请求服务器进行处理(例如提交表单或者上传文件)。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源,或二者皆有。 GET 向指定的资源发出“显示”请求 Status Code:显示 HTTP 请求和状态码,表示 HTTP 请求的状态,此处为 200,表示请求已被服务器接收、理解和处理; 状态代码的第一个数字代表当前响应的类型,HTTP 协议中有以下几种响应类型 1xx 消息——请求已被服务器接收,继续处理 2xx 成功——请求已成功被服务器接收、理解、并接受 3xx 重定向——需要后续操作才能完成这一请求 4xx 请求错误——请求含有词法错误或者无法被执行 Http请求头# Accept:表示请求的资源类型 Cookie:为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据; User-Agent:表示浏览器标识; Accept-Language:表示浏览器所支持的语言类型; Accept-Charset:告诉 Web 服务器,浏览器可以接受哪些字符编码; Accept:表示浏览器支持的 MIME 类型; Accept-Encoding:表示浏览器有能力解码的编码类型; Connection:表示客户端与服务连接类型; 基本的 HTTP 介绍就结束了,如果需要更加详细的 HTTP 知识, 可以阅读相关书籍 编写第一个简单的爬虫#使用python爬去我的博客中的首页中的文章标题 第一步：获取页面#1234567#coding:UTF-8import requestsurl=\"https://baofengketang.com\"data = requests.get(url)headers = &#123;\"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:59.0) Gecko/20100101 Firefox/59.0\"&#125;res = requests.get(url,headers=headers)print(res.text) 注意： requests的headers伪装成浏览器访问 res是requests的Response对象，我们可以从中获取到我们的信息,res.text是获取网页内容代码 第二步：获取需要的数据#首先观察页面中我们需要的数据的特征 测试编写代码 123456789101112#coding:UTF-8import requestsfrom bs4 import BeautifulSoupurl=\"https://baofengketang.com\"data = requests.get(url)headers = &#123;\"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:59.0) Gecko/20100101 Firefox/59.0\"&#125;res = requests.get(url,headers=headers)soup = BeautifulSoup(res.text,\"html.parser\")titles = soup.select(\"div.mini-article__info h3.mini-article__title a\")for i in range(len(titles)): title = titles[i].text.strip() print(\"第%d篇文章的标题是:%s\"%(i+1,title)) 第三步：存储数据#12345678910111213141516171819#coding:UTF-8import requestsfrom bs4 import BeautifulSoupurl=\"https://baofengketang.com\"data = requests.get(url)headers = &#123;\"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:59.0) Gecko/20100101 Firefox/59.0\"&#125;res = requests.get(url,headers=headers)print(res.status_code) #返回状态码print(res.text) #得到响应的结果print(res.encoding)#响应状态码soup = BeautifulSoup(res.text,\"html.parser\")titles = soup.select(\"div.mini-article__info h3.mini-article__title a\")f = open(\"博客.txt\",'w');for i in range(len(titles)): title = titles[i].text.strip() print(\"第%d篇文章的标题是:%s\"%(i+1,title)) f.write(\"第%d篇文章的标题是:%s\"%(i+1,title)+\"\\n\")f.close() 运行结果如下 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://baofengketang.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://baofengketang.com/tags/爬虫/"}]},{"title":"Python网络爬虫环境准备","slug":"python_data/python_data_02","date":"2018-05-10T01:12:14.000Z","updated":"2018-05-31T13:48:11.000Z","comments":true,"path":"2018/05/10/python_data/python_data_02/","link":"","permalink":"http://baofengketang.com/2018/05/10/python_data/python_data_02/","excerpt":"","text":"环境准备 基本知识 开发环境 第三方依赖库 依赖库的安装 环境准备#基本知识#使用 Python 编写爬虫,当然至少得了解 Python 基本的语法,了解以下几点即可 基本数据结构 数据类型 控制流 函数的使用 模块的使用 不需要过多深入的python知识，如果不懂的小伙伴可以阅读我的博客中的python基础章节 开发环境# 操作系统：mac python版本：python3.6 IDE: PyCharm 第三方依赖库# Requests:一个方便、简洁、高效且人性化的 HTTP 请求库 BeautifulSoup:HTML 解析库 Pymongo:MongoDB 的 Python 封装模块 Selenium:一个 Web 自动化测试框架,用于模拟登录和获取 JS 动态数据 Pytesseract:一个 OCR 识别模块,用于验证码识别 Pillow:Python 图像处理模块 依赖库的安装#这里我们不需要安装全部，有选择的安装一下 requests的安装 1pip install requests BeautifulSoup的安装 1pip install bs4 Pymongo的安装 1pip install pymongo Selenium的安装 1pip install selenium pillow的安装 1pip install pillow pytesseract的安装 1pip install pytesseract 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://baofengketang.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://baofengketang.com/tags/爬虫/"}]},{"title":"Python网络爬虫(一)","slug":"python_data/python_data_01","date":"2018-05-09T23:00:32.000Z","updated":"2018-05-31T13:48:04.000Z","comments":true,"path":"2018/05/10/python_data/python_data_01/","link":"","permalink":"http://baofengketang.com/2018/05/10/python_data/python_data_01/","excerpt":"","text":"网络爬虫 爬虫概念 为什么要学习网络爬虫 网络爬虫能带来的好处 大数据分析的基础 网络爬虫是否合法 Robots协议 网络爬虫的约束 网络爬虫的流程 Python爬虫流程 网络爬虫#爬虫概念#网络爬虫是当前互联网比较流行的概念，特别是对于搜索引擎、数据处理等，都需要我们从网上去“取”一些符合要求的数据。总的来说，一般的爬虫分为两个功能模块，也就是取数据和存数据。 取数据是爬虫的关键，特别对于一些具有“防御性”的情况，比如说网站需要登陆的情况，需要挂代理访问的情况，需要限制访问频率的情况，甚至需要输入验证码的情况，都需要在我们设计爬虫方法的时候考虑到。 存数据则是涉及到我们对数据的处理，是保存到数据库中，还是保存到本地文件中，或者临时保存在计算机内存中。 一般所谓的取网页内容，指的是通过程序（某种语言的程序代码，比如Python脚本语言）实现访问某个URL地址，然后获得其所返回的内容（HTML源码，Json格式的字符串等）。然后通过解析规则，分析出我们需要的数据并取出来。 为什么要学习网络爬虫#网络爬虫能带来的好处#对于企业和个人来说，我们都可以通过爬虫来采集互联网的公开数据，那么对于企业来说，爬取互联网的技术有什么好处呢？下面我们以国内几大电商网站为例举例说明 对于某个品牌的电商产品，该品牌需要获悉对手的产品的特点、价格、以及销售情况，才能及时跟进产品开发进度和营销策略从而知己知彼。 过去的常用做法就是让产品研发部手动访问某个页面人工复制到excel中，这种重复性的工作不仅浪费了宝贵的时间，一不留神复制少了一个数据还会导致数据操作，最重要的是，如果对手的数据更新的比较慢，那么我们的数据就缺少时效性，而使用爬虫则能够为我们解决这个问题. 大数据分析的基础#近几年随着大数据的火爆，毕竟有数据才可以分析，网络爬虫已经成为大数据库分析领域的第一个环节，对于这些公开的有价值的数据，我们可以KYC来说明 Know Your Company Know your Competitor Know your Customer 对于数据，我们可以通过机器学习和统计算法分析，在营销领域给企业带来4p Product:产品更新 Place：只能选址 Price:动态价格 Promotion:数据驱动的营销服务 网络爬虫是否合法#互联网已经通过自身协议建立起一个道德规范（Robots协议）但法律部门还在建立和完善中，一半情况如果爬取的数据属于个人或者科研范畴，基本没有问题，而如果数据属于商业范畴，就要就事论事，可能违法也可能不违法。 Robots协议#Robots协议（爬虫协议）全名：“网络爬虫排除标准”（Robots Exclusion Protocol）网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不可以抓取。 以淘宝网为例，我们可以访问如下代码： https://www.taobao.com/robots.txt 该文件则规定了哪些页面可以允许百度爬虫引擎访问，哪些页面不允许页面访问 同时我们在百度中搜索淘宝时也可以发现 网络爬虫的约束#除了robots协议之外，我们使用网络爬虫时还需要对自己进行约束，过于快速或者频繁的网络爬虫都会对服务器产生巨大的压力，网站可能会封锁你的ip，甚至采取进一步的法律行动，因此，你需要约束自己的网络行为，请将请求速度限定在一个合理的范围之内 网络爬虫的流程#Python爬虫流程#网络爬虫的流程实际上非常简单，主要分为三个部分 第一步：获取网页 第二步：解析网页（提取数据） 第三步: 存储数据 1.获取网页就是给一个网址发送一个请求，该网址会返回整个网页的数据，类似于在浏览器中键入一个回车键，然后就可以看到网站的整个内容 2.解析网页就是从整个网页的数据中提取自己想要的数据 3.存书数据也容易理解，就是把提取的数据存储下来，我们可以存储在csv中也可以存储在数据库中 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://baofengketang.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://baofengketang.com/tags/爬虫/"}]},{"title":"Python基础(十二)","slug":"python_base/python_12","date":"2018-05-09T06:43:57.000Z","updated":"2018-05-31T13:49:18.000Z","comments":true,"path":"2018/05/09/python_base/python_12/","link":"","permalink":"http://baofengketang.com/2018/05/09/python_base/python_12/","excerpt":"","text":"模块 模块介绍 python中的模块 import from import from … import * as:为模块起别名 定位模块 模块制作 定义自己的模块 调用自己模块 测试模块 模块中的__all__ 没有__all__的情况 模块中包含__all__ 总结 python中的包 引入包 __init__文件的作用 模块#模块介绍#python中的模块#有过C语言编程经验的朋友都知道在C语言中如果要引用sqrt函数，必须用语句#include &lt;math.h&gt;引入math.h这个头文件，否则是无法正常进行调用的。 那么在Python中，如果要引用一些其他的函数，该怎么处理呢？ 在Python中有一个概念叫做模块（module），这个和C语言中的头文件以及Java中的包很类似，比如在Python中要调用sqrt函数，必须用import关键字引入math这个模块，下面就来了解一下Python中的模块。 说的通俗点：模块就好比是工具包，要想使用这个工具包中的工具(就好比函数)，就需要导入这个模块 import#在Python中用关键字import来引入某个模块，比如要引用模块math，就可以在文件最开始的地方用import math来引入。 形如: 1import module1,mudule2... 当解释器遇到import语句，如果模块在当前的搜索路径就会被导入。 在调用math模块中的函数时，必须这样引用： 1 模块名.函数名 想一想: 为什么必须加上模块名调用呢？ 答: 因为可能存在这样一种情况：在多个模块中含有相同名称的函数，此时如果只是通过函数名来调用，解释器无法知道到底要调用哪个函数。所以如果像上述这样引入模块的时候，调用函数必须加上模块名 12345import math#这样会报错print sqrt(2)#这样才能正确输出结果print math.sqrt(2) 有时候我们只需要用到模块中的某个函数，只需要引入该函数即可，此时可以用下面方法实现： 1from 模块名 import 函数名1,函数名2.... 不仅可以引入函数，还可以引入一些全局变量、类等 注意: 通过这种方式引入的时候，调用函数时只能给出函数名，不能给出模块名，但是当两个模块中含有相同名称函数的时候，后面一次引入会覆盖前一次引入。也就是说假如模块A中有函数function( )，在模块B中也有函数function( )，如果引入A中的function在先、B中的function在后，那么当调用function函数的时候，是去执行模块B中的function函数。 如果想一次性引入math中所有的东西，还可以通过from math import *来实现 from import#Python的from语句让你从模块中导入一个指定的部分到当前命名空间中 语法如下： 1from modname import name1[, name2[, ... nameN]] 例如，要导入模块fib的fibonacci函数，使用如下语句： 1from fib import fibonacci 注意 不会把整个fib模块导入到当前的命名空间中，它只会将fib里的fibonacci单个引入 from … import *#把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： 1from modname import * 注意 这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。 as:为模块起别名#1234567891011In [2]: import time as tmIn [3]: time.sleep(3)---------------------------------------------------------------------------NameError Traceback (most recent call last)&lt;ipython-input-3-127a5bdb7b75&gt; in &lt;module&gt;()----&gt; 1 time.sleep(3)NameError: name 'time' is not definedIn [4]: tm.sleep(3) 主要加入了别名，那么以后只能采用别名访问 定位模块#当你导入一个模块，Python解析器对模块位置的搜索顺序是： 当前目录 如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/ 模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 模块制作#定义自己的模块#在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。 比如有这样一个文件test.py，在test.py中定义了函数add test.py 12def add(a,b): return a+b 调用自己模块#那么在其他文件中就可以先import test，然后通过test.add(a,b)来调用了，当然也可以通过from test import add来引入 my.py 123import testresult = test.add(11,22)print(result) 测试模块#实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如： test.py 1234def add(a,b): return a+bresult =add(1,2)print(\"测试:1+2=%d\"%result) 如果此时，在其他py文件中引入了此文件的话，想想看，测试的那段代码是否也会执行呢！ my.py 12import testprint(test.add(1,2)) 执行结果 123/Library/Frameworks/Python.framework/Versions/3.6/bin/python3 /Users/jinzhong/PycharmProjects/hello3/demo/model/my.py测试:1+2=33 至此，可发现test.py中的测试代码，应该是单独执行test.py文件时才应该执行的，不应该是其他的文件中引用而执行 为了解决这个问题，python在执行一个文件时有个变量__name__ 更改test.py的内容，并且执行 12345def add(a,b): return a+bresult =add(1,2)print(__name__)print(\"测试:1+2=%d\"%result) 观察结果(test.py) 123sh-3.2# python3 test.py__main__测试:1+2=3 观察结果(my.py) 1234sh-3.2# python3 my.pytest测试:1+2=33 总结： 可以根据name变量的结果能够判断出，是直接执行的python脚本还是被引入执行的，从而能够有选择性的执行测试代码 更改test.py代码 123456def add(a,b): return a+bresult =add(1,2)print(__name__)if __name__==\"__main__\": print(\"测试:1+2=%d\"%result) 模块中的__all__#没有__all__的情况#test.py 1234567def add1(): print(\"add1...\")def add2(): print(\"add2...\")if __name__==\"__main__\": add() add2() hello.py 123from test import *add1()add2() 执行结果： add1… add2… 模块中包含__all__#test.py 12345678__all__=[\"add1\"]def add1(): print(\"add1...\")def add2(): print(\"add2...\")if __name__==\"__main__\": add1() add2() hello.py 123from test import *add1()add2() 执行结果： 1234567/Library/Frameworks/Python.framework/Versions/3.6/bin/python3 /Users/jinzhong/PycharmProjects/hello3/demo/model/hello.pyadd1...Traceback (most recent call last): File &quot;/Users/jinzhong/PycharmProjects/hello3/demo/model/hello.py&quot;, line 3, in &lt;module&gt; add2()NameError: name &apos;add2&apos; is not definedProcess finished with exit code 1 总结# 如果一个文件中有__all__变量，那么也就意味着只有这个变量中的元素，才会被from xxx import *时导入 python中的包#引入包#将功能相同的包放在同一个文件夹下 1234567891011121314sh-3.2# pwd/Users/jinzhong/PycharmProjects/hello3/包sh-3.2# tree.├── __init__.py└── vo ├── __init__.py ├── __pycache__ │ ├── __init__.cpython-36.pyc │ └── dog.cpython-36.pyc ├── cat.py └── dog.py2 directories, 6 files 使用import 文件.模块 的方式导入 123456789In [43]: pwdOut[43]: '/Users/jinzhong/PycharmProjects/hello3/包'In [44]: ls__init__.py vo/In [45]: import vo.dogIn [46]: dog.add1()add1..In [47]: dog.add2()add2.. 使用from 文件夹 import 模块 的方式导入 1234567891011In [8]: from vo import *In [9]: dog.add1()---------------------------------------------------------------------------NameError Traceback (most recent call last)&lt;ipython-input-9-2472712858f4&gt; in &lt;module&gt;()----&gt; 1 dog.add1()NameError: name 'dog' is not definedIn [10]: dog.add2() 在__init__.py文件中写入代码 1__all__=[\"dog\"] 再次进行测试 12345678910111213141516In [8]: from vo import *In [9]: dog.add1()add1..In [10]: dog.add2()add2..In [11]: cat.add3()---------------------------------------------------------------------------NameError Traceback (most recent call last)&lt;ipython-input-11-e39bd0c9b05b&gt; in &lt;module&gt;()----&gt; 1 cat.add3()NameError: name 'cat' is not defined 总结1： 包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为__init__.py 文件，那么这个文件夹就称之为包 有效避免模块名称冲突问题，让应用组织结构更加清晰 __init__文件的作用#__init__.py控制着包的导入行为 __init__.py为空:仅仅是把这个包导入，不回导入包中的模块 all__:在init__.py文件中，定义一个__all__变量，它控制着 from 包名 import *时导入的模块 可以在这个文件中编写语句，当导入时，这些语句就会被执行 123&gt;__all__=[&quot;dog&quot;]&gt;print(&quot;******&quot;)&gt; 继续执行导入操作 123&gt;In [7]: from vo import *&gt;******&gt; 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"Python基础(十一)","slug":"python_base/python_11","date":"2018-05-09T01:35:58.000Z","updated":"2018-05-31T13:49:18.000Z","comments":true,"path":"2018/05/09/python_base/python_11/","link":"","permalink":"http://baofengketang.com/2018/05/09/python_base/python_11/","excerpt":"","text":"异常 异常简介 捕获异常 捕获异常try … exception exception捕获多个异常 捕获所有异常 else try…finally… 异常的传递 try嵌套中 函数嵌套调用中 抛出自定义的异常 异常处理中抛出异常 异常#异常简介#看下面的例子 123print(\"*\"*50)f=open(\"hello1.txt\")＃该文件不存在print(\"*\"*50) 运行结果 1234567/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test20.pyTraceback (most recent call last):************************************************** File &quot;/Users/jinzhong/PycharmProjects/hello3/demo/test20.py&quot;, line 2, in &lt;module&gt; f=open(&quot;hello1.txt&quot;)FileNotFoundError: [Errno 2] No such file or directory: &apos;hello1.txt&apos;Process finished with exit code 1 说明: 打开一个不存在的文件123.txt，当找不到123.txt 文件时，就会抛出给我们一个IOError类型的错误，No such file or directory：123.txt （没有123.txt这样的文件或目录） 异常: 当Python检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的”异常” 捕获异常#捕获异常try … exception#看如下示例: 123456try: print(\"*\"*50) f=open(\"hello1.txt\") print(\"*\"*50)except IOError: pass 运行结果 1234/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test20.py**************************************************Process finished with exit code 0 说明: 此程序看不到任何错误，因为用except 捕获到了IOError异常，并添加了处理的方法 pass 表示实现了相应的实现，但什么也不做；如果把pass改为print语句，那么就会输出其他信息 小总结: 把可能出现问题的代码，放在try中 把处理异常的代码，放在except中 exception捕获多个异常#看下面的案例 1234567try: print(\"*\"*50) f=open(\"hello.txt\") print(\"*\"*50) print(num)except IOError: pass 运行结果 12345678/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test20.py**************************************************Traceback (most recent call last):************************************************** File &quot;/Users/jinzhong/PycharmProjects/hello3/demo/test20.py&quot;, line 5, in &lt;module&gt; print(num)NameError: name &apos;num&apos; is not definedProcess finished with exit code 1 想一想: 上例程序，已经使用except来捕获异常了，为什么还会看到错误的信息提示？ 答: except捕获的错误类型是IOError，而此时程序产生的异常为 NameError ，所以except没有生效 修改后的代码为: 123456789try: print(\"*\"*50) f=open(\"hello.txt\") print(\"*\"*50) print(num)except IOError: print(\"产生了io异常\")except NameError: print(\"对不起，变量未定义\") 实际开发中，捕获多个异常方式也可以通过如下代码 1234567try: print(\"*\"*50) f=open(\"hello.txt\") print(\"*\"*50) print(num)except (IOError,NameError) as result: #result可以保存异常的原始信息 print(result) 注意 当捕获多个异常时，可以把要捕获的异常的名字，放到except 后，并使用元组的方式仅进行存储 捕获所有异常#1234567try: print(\"*\"*50) f=open(\"hello.txt\") print(\"*\"*50) print(num)except Exception as result: print(result) else#在if中，它的作用是当条件不满足时执行的实行；同样在try…except…中也是如此，即如果没有捕获到异常，那么就执行else中的事情 1234567try: num = 100 print(num)except NameError as errorMsg: print('产生错误了:%s'%errorMsg)else: print('没有捕获到异常，真高兴') 运行结果 1234/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test20.py100没有捕获到异常，真高兴Process finished with exit code 0 try…finally…#try…finally…语句用来表达这样的情况： 在程序中，如果一个段代码必须要执行，即无论异常是否产生都要执行，那么此时就需要使用finally。 比如文件关闭，释放锁，把数据库连接返还给连接池等 demo(终端演示): 12345678910111213141516171819import timetry: f = open('hello.txt') try: while True: content = f.readline() if len(content) == 0: break time.sleep(2) print(content) except: #如果在读取文件的过程中，产生了异常，那么就会捕获到 #比如 按下了 ctrl+c pass finally: f.close() print('关闭文件')except: print(\"没有这个文件\") 说明: test.txt文件中每一行数据打印，但是我有意在每打印一行之前用time.sleep方法暂停2秒钟。这样做的原因是让程序运行得慢一些。在程序运行的时候，按Ctrl+c中断（取消）程序。 我们可以观察到KeyboardInterrupt异常被触发，程序退出。但是在程序退出之前，finally从句仍然被执行，把文件关闭。 异常的传递#try嵌套中#123456789101112131415import timetry: f = open('test.txt') try: while True: content = f.readline() if len(content) == 0: break time.sleep(2) print(content) finally: f.close() print('关闭文件')except: print(\"没有这个文件\") 运行结果: 12345678910111213141516171819202122In [26]: import time ...: try: ...: f = open('test.txt') ...: try: ...: while True: ...: content = f.readline() ...: if len(content) == 0: ...: break ...: time.sleep(2) ...: print(content) ...: finally: ...: f.close() ...: print('关闭文件') ...: except: ...: print(\"没有这个文件\") ...: finally: ...: print(\"最后的finally\") ...: xxxxxxx---&gt;这是test.txt文件中读取到信息^C关闭文件没有这个文件最后的finally 函数嵌套调用中#123456789101112131415161718192021222324def test1(): print(\"----test1-1----\") print(num) print(\"----test1-2----\")def test2(): print(\"----test2-1----\") test1() print(\"----test2-2----\")def test3(): try: print(\"----test3-1----\") test1() print(\"----test3-2----\") except Exception as result: print(\"捕获到了异常，信息是:%s\"%result) print(\"----test3-2----\")test3()print(\"------华丽的分割线-----\")test2() 总结： 如果try嵌套，那么如果里面的try没有捕获到这个异常，那么外面的try会接收到这个异常，然后进行处理，如果外边的try依然没有捕获到，那么再进行传递。。。 如果一个异常是在一个函数中产生的，例如函数A—-&gt;函数B—-&gt;函数C,而异常是在函数C中产生的，那么如果函数C中没有对这个异常进行处理，那么这个异常会传递到函数B中，如果函数B有异常处理那么就会按照函数B的处理方式进行执行；如果函数B也没有异常处理，那么这个异常会继续传递，以此类推。。。如果所有的函数都没有处理，那么此时就会进行异常的默认处理，即通常见到的那样 注意观察上图中，当调用test3函数时，在test1函数内部产生了异常，此异常被传递到test3函数中完成了异常处理，而当异常处理完后，并没有返回到函数test1中进行执行，而是在函数test3中继续执行 抛出自定义的异常#你可以用raise语句来引发一个异常。异常/错误对象必须有一个名字，且它们应是Error或Exception类的子类 下面是一个引发异常的例子: 12345678910111213141516171819class ShortInputException(Exception): '''自定义的异常类''' def __init__(self, length, atleast): #super().__init__() self.length = length self.atleast = atleastdef main(): try: s = input('请输入 --&gt; ') if len(s) &lt; 3: # raise引发一个你定义的异常 raise ShortInputException(len(s), 3) except ShortInputException as result:#x这个变量被绑定到了错误的实例 print('ShortInputException: 输入的长度是 %d,长度至少应是 %d'% (result.length, result.atleast)) else: print('没有异常发生.')main() 运行结果 1234请输入 --&gt; hello没有异常发生.请输入 --&gt; tShortInputException: 输入的长度是 1,长度至少应是 3 注意： 以上程序中，关于代码#super().__init__()的说明 这一行代码，可以调用也可以不调用，建议调用，因为__init__方法往往是用来对创建完的对象进行初始化工作，如果在子类中重写了父类的__init__方法，即意味着父类中的很多初始化工作没有做，这样就不保证程序的稳定了，所以在以后的开发中，如果重写了父类的__init__方法，最好是先调用父类的这个方法，然后再添加自己的功能 异常处理中抛出异常#1234567891011121314151617181920class Test(object): def __init__(self, switch): self.switch = switch #开关 def calc(self, a, b): try: return a/b except Exception as result: if self.switch: print(\"捕获开启，已经捕获到了异常，信息如下:\") print(result) else: #重新抛出这个异常，此时就不会被这个异常处理给捕获到，从而触发默认的异常处理 raisea = Test(True) ## 处理异常a.calc(11,0)print(\"----------------------华丽的分割线----------------\")a.switch = False ## 不处理异常a.calc(11,0) 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"Python基础(十)","slug":"python_base/python_10","date":"2018-05-08T15:13:20.000Z","updated":"2018-05-31T13:49:19.000Z","comments":true,"path":"2018/05/08/python_base/python_10/","link":"","permalink":"http://baofengketang.com/2018/05/08/python_base/python_10/","excerpt":"","text":"面向对象（三） __new__方法 单例模式 面向对象（三）#__new__方法#new__和init__的作用 123456789101112class Dog(object): def __init__(self): print(\"对象初始化\") def __str__(self): pass def __del__(self): pass def __new__(cls): print(\"对象创建\") return object.__new__(cls)dog=Dog() 总结： __new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供 __new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类__new__出来的实例，或者直接是object的__new__出来的实例 __init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值 我们可以将类比作制造商，__new__方法就是前期的原材料购买环节，__init__方法就是在有原材料的基础上，加工，初始化商品环节 注意： 单例模式#1.单例是什么 举个常见的单例模式例子，我们日常使用的电脑上都有一个回收站，在整个操作系统中，回收站只能有一个实例，整个系统都使用这个唯一的实例，而且回收站自行提供自己的实例。因此回收站是单例模式的应用。 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式。 2.创建单例模式 1234567891011121314151617181920# 实例化一个单例class Singleton(object): __instance = None def __new__(cls, age, name): #如果类数字能够__instance没有或者没有赋值 #那么就创建一个对象，并且赋值为这个对象的引用，保证下次调用这个方法时 #能够知道之前已经创建过对象了，这样就保证了只有1个对象 if not cls.__instance: cls.__instance = object.__new__(cls) return cls.__instancea = Singleton(18, \"zhangsan\")b = Singleton(8, \"lisi\")print(id(a))print(id(b))a.age = 19 #给a指向的对象添加一个属性print(b.age)#获取b指向的对象的age属性 运行结果 12345/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test19.py4369269256436926925619Process finished with exit code 0 3.创建单例时，只执行1次__init__方法 12345678910111213141516171819202122232425# 实例化一个单例class Singleton(object): __instance = None __first_init = False def __new__(cls, age, name): if not cls.__instance: cls.__instance = object.__new__(cls) return cls.__instance def __init__(self, age, name): if self.__first_init==False: self.age = age self.name = name Singleton.__first_init = Truea = Singleton(18, \"zhangsan\")b = Singleton(8, \"lisi\")print(id(a))print(id(b))print(a.age)print(b.age)a.age = 19print(b.age) 运行结果 1234567/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test19.py45035402324503540232181819Process finished with exit code 0 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"Python基础(九)","slug":"python_base/python_09","date":"2018-05-08T13:11:50.000Z","updated":"2018-05-31T13:49:20.000Z","comments":true,"path":"2018/05/08/python_base/python_09/","link":"","permalink":"http://baofengketang.com/2018/05/08/python_base/python_09/","excerpt":"","text":"面向对象设计 设计类 设计一个买车的4s店 设计一个买宝马车的4s店 简单工厂模式 使用函数来解决 使用类来实现 工厂方法模式 面向对象设计#设计类#设计一个买车的4s店#123456789101112131415161718# 定义一个车类class Car: # 定义车的方法 def move(self): print(\"车在移动\") def stop(self): print(\"停车\")# 定义一个汽车cs店类class Store: def order(self): print('产生一辆汽车') return Car()store=Store()car =store.order()car.move()car.stop() 说明 上面的4s店，只能销售那一种类型的车 如果这个是个销售宝马品牌的车，比如550、x6,x1等，该怎样做呢？ 设计一个买宝马车的4s店#1234567891011121314151617181920212223242526272829303132333435363738# 定义一个车类class Car: # 定义车的方法 def move(self): print(\"车在移动\") def stop(self): print(\"停车\")#定义三个子类class Bwm550(Car): def __str__(self): return \"550被领走了\"class X1(Car): def __str__(self): return \"x1被领走了\"class X6(Car): def __str__(self): return \"x6被领走了\"# 定义一个汽车cs店类class Store: def order(self,type): print('产生一辆汽车') if type==\"550\": return Bwm550() elif type ==\"X1\": return X1() elif type ==\"X6\": return X6() else: return Car()# 测试store=Store()car1 =store.order(\"550\")print(car1)car2 =store.order(\"X6\")print(car2)car3 = store.order(\"X1\")print(car3) 运行结果 12345678/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test17.py产生一辆汽车550被领走了产生一辆汽车x6被领走了产生一辆汽车x1被领走了Process finished with exit code 0 这样做，不太好，因为当宝马又生产一种新类型的车时，又得在Store类中修改，有没有好的解决办法呢？ 简单工厂模式#使用函数来解决#1234567891011121314151617181920212223242526272829303132333435363738394041# 定义一个车类class Car: # 定义车的方法 def move(self): print(\"车在移动\") def stop(self): print(\"停车\")#定义三个子类class Bwm550(Car): def __str__(self): return \"550被领走了\"class X1(Car): def __str__(self): return \"x1被领走了\"class X6(Car): def __str__(self): return \"x6被领走了\"# 定义一个汽车cs店类class Store: def order(self,type): print('产生一辆汽车') return createCar(type)# 定义一个函数用来生成具体的对象def createCar(type): if type == \"550\": return Bwm550() elif type == \"X1\": return X1() elif type == \"X6\": return X6() else: return Car()# 测试store=Store()car1 =store.order(\"550\")print(car1)car2 =store.order(\"X6\")print(car2)car3 = store.order(\"X1\")print(car3) 使用类来实现#12345678910111213141516171819202122232425262728293031323334353637383940414243# 定义一个车类class Car: # 定义车的方法 def move(self): print(\"车在移动\") def stop(self): print(\"停车\")#定义三个子类class Bwm550(Car): def __str__(self): return \"550被领走了\"class X1(Car): def __str__(self): return \"x1被领走了\"class X6(Car): def __str__(self): return \"x6被领走了\"# 定义一个汽车cs店类class Store: def order(self,type): print('产生一辆汽车') return Factory.createCar(type)# 定义一个工厂类，通过工厂类的静态方法产生对象class Factory: @staticmethod def createCar(type): if type == \"550\": return Bwm550() elif type == \"X1\": return X1() elif type == \"X6\": return X6() else: return Car()# 测试store=Store()car1 =store.order(\"550\")print(car1)car2 =store.order(\"X6\")print(car2)car3 = store.order(\"X1\")print(car3) 咋一看来，好像只是把生产环节重新创建了一个类，这确实比较像是一种编程习惯，此种解决方式被称作简单工厂模式 工厂函数、工厂类对具体的生成环节进行了封装，这样有利于代码的后需扩展，即把功能划分的更具体，4s店只负责销售，汽车厂只负责制造 工厂方法模式#当买车时，我们发现4s店其实很多，现在要求在系统里在增加一个斯柯达的4s店，我们应该如何考虑呢 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 定义一个车类class Car: # 定义车的方法 def move(self): print(\"车在移动\") def stop(self): print(\"停车\")#定义三个子类class Bwm550(Car): def __str__(self): return \"550被领走了\"class X1(Car): def __str__(self): return \"x1被领走了\"class X6(Car): def __str__(self): return \"x6被领走了\"# 定义斯柯达汽车类class MR(Car): def __str__(self): return \"明锐被领走了\"class JR(Car): def __str__(self): return \"晶锐被领走类\"# 定义4s店的父类class Store(object): def getCar(self,type): pass; def order(self,type): return self.getCar(type);# 定义一个宝马4s店类class BwmStore(Store): def getCar(self,type): return BwmFactory.createCar(type);class SkdStore(Store): def getCar(self,type): return SkdFactory.createCar(type);class SkdFactory: @staticmethod def createCar(type): if type==\"明锐\": return MR(); else: return JR();# 定义一个函数用来生成具体的对象class BwmFactory: @staticmethod def createCar(type): if type == \"550\": return Bwm550() elif type == \"X1\": return X1() elif type == \"X6\": return X6() else: return Car()# 测试store=BwmStore()car1 =store.order(\"550\")print(car1)car2 =store.order(\"X6\")print(car2)car3 = store.order(\"X1\")print(car3)store2 =SkdStore();car4=store2.order(\"明锐\")print(car4)car5=store2.order(\"晶锐\")print(car5) 最后来看看工厂方法模式的定义 定义了一个创建对象的接口(可以理解为函数)，但由子类决定要实例化的类是哪一个，工厂方法模式让类的实例化推迟到子类，抽象的CarStore提供了一个创建对象的方法createCar，也叫作工厂方法。 子类真正实现这个createCar方法创建出具体产品。 创建者类不需要直到实际创建的产品是哪一个，选择了使用了哪个子类，自然也就决定了实际创建的产品是什么。 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"Python基础(八)","slug":"python_base/python_08","date":"2018-05-08T04:41:28.000Z","updated":"2018-05-31T13:49:21.000Z","comments":true,"path":"2018/05/08/python_base/python_08/","link":"","permalink":"http://baofengketang.com/2018/05/08/python_base/python_08/","excerpt":"","text":"面向对象（二） 保护对象属性 __del__()方法 继承介绍以及单继承 多继承 重写父类方法与调用父类方法 多态 类属性、实例属性 静态方法和类方法 总结 面向对象（二）#保护对象属性#如果有一个对象，当需要对其进行修改属性时，有2种方法 对象名.属性名 = 数据 —-&gt;直接修改 对象名.方法名() —-&gt;间接修改 为了更好的保存属性安全，即不能随意修改，一般的处理方式为 将属性定义为私有属性 添加一个可以调用的方法，供调用 12345678910111213class People(object): def __init__(self, name): self.__name = name def getName(self): return self.__name def setName(self, newName): if len(newName) &gt;= 5: self.__name = newName else: print(\"error:名字长度需要大于或者等于5\")xiaoming = People(\"张三疯\")print(xiaoming.__name) 运行结果 123456/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test16.pyTraceback (most recent call last): File \"/Users/jinzhong/PycharmProjects/hello3/demo/test16.py\", line 13, in &lt;module&gt; print(xiaoming.__name)AttributeError: 'People' object has no attribute '__name'Process finished with exit code 1 上面的运行结果发现，__name不能直接被访问，接下来我们可以通过set、get方法来进行设置和访问 123456789101112131415class People(object): def __init__(self, name): self.__name = name def getName(self): return self.__name def setName(self, newName): if len(newName) &gt;= 5: self.__name = newName else: print(\"error:名字长度需要大于或者等于5\")p = People(\"xiaot\")p.setName(\"as仙阁－辰鬼\")print(p.getName())p.setName(\"lisi\")print(p.getName()) 运行结果 12345/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test16.pyas仙阁－辰鬼error:名字长度需要大于或者等于5as仙阁－辰鬼Process finished with exit code 0 总结 Python中没有像C++中public和private这些关键字来区别公有属性和私有属性 它是以属性命名方式来区分，如果在属性名前面加了2个下划线’__’，则表明该属性是私有属性，否则为公有属性（方法也是一样，方法名前面加了2个下划线的话表示该方法是私有的，否则为公有的）。 __del__()方法#创建对象后，python解释器默认调用__init__()方法； 当删除一个对象时，python解释器也会默认调用一个方法，这个方法为__del__()方法 12345678910111213141516171819202122232425262728import timeclass Animal(object): # 初始化方法 # 创建完对象后会自动被调用 def __init__(self, name): print('__init__方法被调用') self.__name = name # 析构方法 # 当对象被删除时，会自动被调用 def __del__(self): print(\"__del__方法被调用\") print(\"%s对象马上被干掉了...\"%self.__name)# 创建对象dog = Animal(\"哈皮狗\")# 删除对象del dogcat = Animal(\"波斯猫\")cat2 = catcat3 = catprint(\"---马上 删除cat对象\")del catprint(\"---马上 删除cat2对象\")del cat2print(\"---马上 删除cat3对象\")del cat3print(\"程序2秒钟后结束\")time.sleep(2) 运行结果 123456789101112/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test16.py__init__方法被调用__del__方法被调用哈皮狗对象马上被干掉了...__init__方法被调用---马上 删除cat对象---马上 删除cat2对象---马上 删除cat3对象__del__方法被调用波斯猫对象马上被干掉了...程序2秒钟后结束Process finished with exit code 0 总结 当有1个变量保存了对象的引用时，此对象的引用计数就会加1 当使用del删除变量指向的对象时，如果对象的引用计数不会1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除 补充： 在python中我们可以通过sys.getrefcount()方法来测试对象的引用计数器，通过sys.getrefcount()方法得到的引用计数比实际个数多一个 12345678910111213141516171819202122import sysimport timeclass Animal(object): # 初始化方法 # 创建完对象后会自动被调用 def __init__(self, name): print('__init__方法被调用') self.__name = name # 析构方法 # 当对象被删除时，会自动被调用 def __del__(self): print(\"__del__方法被调用\") print(\"%s对象马上被干掉了...\"%self.__name)cat = Animal(\"波斯猫\")cat2 = catcat3 = catprint(sys.getrefcount(cat3))del cat3print(sys.getrefcount(cat2))del cat2print(sys.getrefcount(cat)) 运行结果 12345678/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test16.py__init__方法被调用432__del__方法被调用波斯猫对象马上被干掉了...Process finished with exit code 0 继承介绍以及单继承#继承的概念 在现实生活中，继承一般指的是子女继承父辈的财产 在程序中，继承描述的是事物之间的所属关系，例如猫和狗都属于动物，程序中便可以描述为猫和狗继承自动物；同理，波斯猫和巴厘猫都继承自猫，而沙皮狗和斑点狗都继承狗 2.继承实例 1234567891011121314151617181920212223# 定义一个父类，如下:class Cat(object): def __init__(self, name, color=\"白色\"): self.name = name self.color = color def run(self): print(\"%s--在跑\"%self.name)# 定义一个子类，继承Cat类如下:class Bosi(Cat): def setNewName(self, newName): self.name = newName def eat(self): print(\"%s--在吃\"%self.name)bs = Bosi(\"印度猫\")print('bs的名字为:%s'%bs.name)print('bs的颜色为:%s'%bs.color)bs.eat()bs.setNewName('波斯')bs.run() 运行结果 123456/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test16.pybs的名字为:印度猫bs的颜色为:白色印度猫--在吃波斯--在跑Process finished with exit code 0 说明： 虽然子类没有定义__init__方法，但是父类有，所以在子类继承父类的时候这个方法就被继承了，所以只要创建Bosi的对象，就默认执行了那个继承过来的__init__方法 总结 子类在继承的时候，在定义类时，小括号()中为父类的名字 父类的属性、方法，会被继承给子类 注意点 1234567891011121314151617181920212223242526class Animal(object): def __init__(self, name='动物', color='白色'): self.__name = name self.color = color def __test(self): print(self.__name) print(self.color) def test(self): print(self.__name) print(self.color)class Dog(Animal): def dogTest1(self): #print(self.__name) #不能访问到父类的私有属性 print(self.color) def dogTest2(self): #self.__test() #不能访问父类中的私有方法 self.test()A = Animal()#print(A.__name) #程序出现异常，不能访问私有属性print(A.color)#A.__test() #程序出现异常，不能访问私有方法A.test()print(\"------分割线-----\")D = Dog(name = \"小花狗\", color = \"黄色\")D.dogTest1()D.dogTest2() 私有的属性，不能通过对象直接访问，但是可以通过方法访问 私有的方法，不能通过对象直接访问 私有的属性、方法，不会被子类继承，也不能被访问 一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用 多继承# 从图中能够看出，所谓多继承，即子类有多个父类，并且具有它们的特征 Python中多继承的格式如下: 123456789101112131415161718# 定义一个父类class A: def printA(self): print('----A----')# 定义一个父类class B: def printB(self): print('----B----')# 定义一个子类，继承自A、Bclass C(A,B): def printC(self): print('----C----')obj_C = C()obj_C.printA()obj_C.printB() 运行结果: 12----A--------B---- 说明 python中是可以多继承的 父类中的方法、属性，子类会继承 注意点 如果在上面的多继承例子中，如果父类A和父类B中，有一个同名的方法，那么通过子类去调用的时候，调用哪个？ 1234567891011121314151617#coding=utf-8class base(object): def test(self): print('----base test----')class A(base): def test(self): print('----A test----')# 定义一个父类class B(base): def test(self): print('----B test----')# 定义一个子类，继承自A、Bclass C(A,B): passobj_C = C()obj_C.test()print(C.__mro__) #可以查看C类的对象搜索方法时的先后顺序 重写父类方法与调用父类方法#1.重写父类方法 所谓重写，就是子类中，有一个和父类相同名字的方法，在子类中的方法会覆盖掉父类中同名的方法 123456789#coding=utf-8class Cat(object): def sayHello(self): print(\"haha\")class Bosi(Cat): def sayHello(self): print(\"hehe\")bosi = Bosi()bosi.sayHello() 运行结果 123/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test16.pyheheProcess finished with exit code 0 2.调用方法 123456789101112131415161718#coding=utf-8class Cat(object): def __init__(self,name): self.name = name self.color = 'yellow'class Bosi(Cat): def __init__(self,name): # 调用父类的__init__方法1(python2) #Cat.__init__(self,name) # 调用父类的__init__方法2 # super(Bosi,self).__init__(name) # 调用父类的__init__方法3 super().__init__(name) def getName(self): return self.namebosi = Bosi('妮妮')print(bosi.name)print(bosi.color) 运行结果 1234/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test16.py妮妮yellowProcess finished with exit code 0 多态#多态的概念是应用于Java和C#这一类强类型语言中，而Python崇尚“鸭子类型”。 所谓多态：定义时的类型和运行时的类型不一样，此时就成为多态 Python伪代码实现Java或C#的多态 1234567891011121314151617181920212223242526class F1(object): def show(self): print 'F1.show'class S1(F1): def show(self): print 'S1.show'class S2(F1): def show(self): print 'S2.show'# 由于在Java或C#中定义函数参数时，必须指定参数的类型# 为了让Func函数既可以执行S1对象的show方法，又可以执行S2对象的show方法，所以，定义了一个S1和S2类的父类# 而实际传入的参数是：S1对象和S2对象def Func(F1 obj): \"\"\"Func函数需要接收一个F1类型或者F1子类的类型\"\"\" print obj.show()s1_obj = S1()Func(s1_obj) # 在Func函数中传入S1类的对象 s1_obj，执行 S1 的show方法，结果：S1.shows2_obj = S2()Func(s2_obj) # 在Func函数中传入Ss类的对象 ss_obj，执行 Ss 的show方法，结果：S2.show Python “鸭子类型” 12345678910111213141516class F1(object): def show(self): print 'F1.show'class S1(F1): def show(self): print 'S1.show'class S2(F1): def show(self): print 'S2.show'def Func(obj): print obj.show()s1_obj = S1()Func(s1_obj) s2_obj = S2()Func(s2_obj) 类属性、实例属性#了解了类基本的东西之后，下面看一下python中这几个概念的区别 先来谈一下类属性和实例属性 在前面的例子中我们接触到的就是实例属性（对象属性），顾名思义，类属性就是类对象 所拥有的属性，它被所有类对象的实例对象所共有，在内存中只存在一个副本，这个和C++中类的静态成员变量有点类似。对于公有的类属性，在类外可以通过类对象和实例对象访问 12345678class People(object): name = 'Tom' #公有的类属性 __age = 12 #私有的类属性p = People()print(p.name) #正确print(People.name) #正确print(p.__age) #错误，不能在类外通过实例对象访问私有的类属性print(People.__age) #错误，不能在类外通过类对象访问私有的类属性 实例属性（对象属性） 12345678910111213class People(object): address = '山东' #类属性 def __init__(self): self.name = 'xiaowang' #实例属性 self.age = 20 #实例属性p = People()p.age =12 #实例属性print(p.address) #正确print(p.name) #正确print(p.age) #正确print(People.address) #正确print(People.name) #错误print(People.age) #错误 通过实例对象去修改类属性 12345678910class People(object): country = 'china' #类属性print(People.country)p = People()print(p.country)p.country = 'japan'print(p.country) #实例属性会屏蔽掉同名的类属性print(People.country)del p.country #删除实例属性print(p.country) 总结 如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。 静态方法和类方法#1.类方法 是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以’cls’作为第一个参数的名字，就最好用’cls’了），能够通过实例对象和类对象去访问。 1234567891011class People(object): country = 'china' #类方法，用classmethod来进行修饰 @classmethod def getCountry(cls): return cls.countryp = People()print p.getCountry() #可以用过实例对象引用print People.getCountry() #可以通过类对象引用 类方法还有一个用途就是可以对类属性进行修改： 123456789101112131415161718192021class People(object): country = 'china' #类方法，用classmethod来进行修饰 @classmethod def getCountry(cls): return cls.country @classmethod def setCountry(cls,country): cls.country = countryp = People()print p.getCountry() #可以用过实例对象引用print People.getCountry() #可以通过类对象引用p.setCountry('japan') print p.getCountry() print People.getCountry() 运行结果 1234chinachinajapanjapan 结果显示在用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变 2.静态方法 需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数 1234567class People(object): country = 'china' @staticmethod #静态方法 def getCountry(): return People.countryprint People.getCountry() 总结#从类方法和实例方法以及静态方法的定义形式就可以看出来，类方法的第一个参数是类对象cls，那么通过cls引用的必定是类对象的属性和方法；而实例方法的第一个参数是实例对象self，那么通过self引用的可能是类属性、也有可能是实例属性（这个需要具体分析），不过在存在相同名称的类属性和实例属性的情况下，实例属性优先级更高。静态方法中不需要额外定义参数，因此在静态方法中引用类属性的话，必须通过类对象来引用 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"Python基础(七)","slug":"python_base/python_07","date":"2018-05-08T02:00:07.000Z","updated":"2018-05-31T13:49:21.000Z","comments":true,"path":"2018/05/08/python_base/python_07/","link":"","permalink":"http://baofengketang.com/2018/05/08/python_base/python_07/","excerpt":"","text":"面向对象 面向对象编程介绍 类和对象 定义类 创建对象 __init__()方法 魔法方法 self 面向对象案例1 面向对象案例2 面向对象#面向对象编程介绍#想一想:用程序描述以下事情 A同学报道登记信息 B同学报道登记信息 C同学报道登记信息 A同学做自我介绍 B同学做自我介绍 C同学做自我介绍 1234567891011121314151617181920212223242526stu_a = &#123; \"name\":\"A\", \"age\":21, \"gender\":1, \"hometown\":\"河北\"&#125;stu_b = &#123; \"name\":\"B\", \"age\":22, \"gender\":0, \"hometown\":\"山东\"&#125;stu_c = &#123; \"name\":\"C\", \"age\":20, \"gender\":1, \"hometown\":\"安徽\"&#125;def stu_intro(stu): \"\"\"自我介绍\"\"\" for key, value in stu.items(): print(\"key=%s, value=%d\"%(key,value))stu_intro(stu_a)stu_intro(stu_b)stu_intro(stu_c) 考虑现实生活中，我们的思维方式是放在学生这个个人上，是学生做了自我介绍。而不是像我们刚刚写出的代码，先有了介绍的行为，再去看介绍了谁。 用我们的现实思维方式该怎么用程序表达呢？ 123456stu_a = Student(个人信息)stu_b = Student(个人信息)stu_c = Student(个人信息)stu_a.intro()stu_a.intro()stu_a.intro() 面向过程：根据业务逻辑从上到下写代码 面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程 面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑。 今天我们来学习一种新的编程方式：面向对象编程（Object Oriented Programming，OOP，面向对象程序设计） 今天我们来学习一种新的编程方式：面向对象编程（Object Oriented Programming，OOP，面向对象程序设计） 1）解决菜鸟买电脑的故事 第一种方式: 1)在网上查找资料 2)根据自己预算和需求定电脑的型号 MacBook 15 顶配 1W8 3)去市场找到苹果店各种店无法甄别真假 随便找了一家 4)找到业务员,业务员推荐了另外一款 配置更高价格便宜,也是苹果系统的 1W 5)砍价30分钟 付款9999 6)成交 回去之后发现各种问题 第二种方式 : 1)找一个靠谱的电脑高手 2)给钱交易 面向对象和面向过程都是解决问题的一种思路而已 买电脑的第一种方式: 强调的是步骤、过程、每一步都是自己亲自去实现的 这种解决问题的思路我们就叫做面向过程 买电脑的第二种方式: 强调的是电脑高手, 电脑高手是处理这件事的主角,对我们而言,我们并不必亲自实现整个步骤只需要调用电脑高手就可以解决问题 这种解决问题的思路就 是面向对象 用面向对象的思维解决问题的重点 当遇到一个需求的时候不用自己去实现，如果自己一步步实现那就是面向过程 应该找一个专门做这个事的人来做 面向对象是基于面向过程的 面向对象(object-oriented ;简称: OO) 至今还没有统一的概念 我这里把它定义为: 按人们认识客观世界的系统思维方式,采用基于对象(实体) 的概念建立模型,模拟客观世界分析、设 计、实现软件的办法。 面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。 类和对象#面向对象编程的2个非常重要的概念：类和对象 对象是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念——类 类就相当于制造飞机时的图纸，用它来进行创建的飞机就相当于对象 1.类 123人以类聚 物以群分。具有相似内部状态和运动规律的实体的集合(或统称为抽象)。 具有相同属性和行为事物的统称 类是抽象的,在使用的时候通常会找到这个类的一个具体的存在,使用这个具体的存在。一个类可以找到多个对象 2.对象 12某一个具体事物的存在 ,在现实世界中可以是看得见摸得着的。可以是直接使用的 3.类与对象的关系 类就是创建对象的模板 4.类的构成 类(Class) 由3个部分构成 类的名称:类名 类的属性:一组数据 类的方法:允许对进行操作的方法 (行为) 举例： 1）人类设计,只关心3样东西: 事物名称(类名):人(Person) 属性:身高(height)、年龄(age) 方法(行为/功能):跑(run)、打架(fight) 2）狗类的设计 类名:狗(Dog) 属性:品种 、毛色、性别、名字、 腿儿的数量 方法(行为/功能):叫 、跑、咬人、吃、摇尾巴 定义类#定义一个类，格式如下： 12class 类名: 方法列表 demo：定义一个Car类 12345678# 定义类class Car: # 方法 def getCarInfo(self): print('车轮子个数:%d, 颜色%s'%(self.wheelNum, self.color)) def move(self): print(\"车正在移动...\") 说明： 定义类时有2种：新式类和经典类，上面的Car为经典类，如果是Car(object)则为新式类 类名 的命名规则按照”大驼峰” 创建对象#定义了一个Car类；就好比有车一个张图纸，那么接下来就应该把图纸交给生成工人们去生成了 python中，可以根据已经定义的类去创建出一个个对象 创建对象的格式为: 1对象名 = 类名() 创建对象demo: 12345678910111213141516171819# 定义类class Car: # 移动 def move(self): print('车在奔跑...') # 鸣笛 def toot(self): print(\"车在鸣笛...嘟嘟..\")# 创建一个对象，并用变量BMW来保存它的引用BMW = Car()BMW.color = '黑色'BMW.wheelNum = 4 #轮子数量BMW.move()BMW.toot()print(BMW.color)print(BMW.wheelNum) 总结 BMW = Car()，这样就产生了一个Car的实例对象，此时也可以通过实例对象BMW来访问属性或者方法 第一次使用BMW.color = ‘黑色’表示给BMW这个对象添加属性，如果后面再次出现BMW.color = xxx表示对属性进行修改 BMW是一个对象，它拥有属性（数据）和方法（函数） 当创建一个对象时，就是用一个模子，来制造一个实物 __init__()方法#想一想: 在上一小节的demo中，我们已经给BMW这个对象添加了2个属性，wheelNum（车的轮胎数量）以及color（车的颜色），试想如果再次创建一个对象的话，肯定也需要进行添加属性，显然这样做很费事，那么有没有办法能够在创建对象的时候，就顺便把车这个对象的属性给设置呢？ __init__()方法 1.使用方式 1234def 类名: #初始化函数，用来完成一些默认的设定 def __init__(): pass 2.__init__()方法的调用 1234567891011121314# 定义汽车类class Car: def __init__(self): self.wheelNum = 4 self.color = '蓝色' def move(self): print('车在跑，目标:夏威夷')# 创建对象BMW = Car()print('车的颜色为:%s'%BMW.color)print('车轮胎数量为:%d'%BMW.wheelNum) 总结 当创建Car对象后，在没有调用__init__()方法的前提下，BMW就默认拥有了2个属性wheelNum和color，原因是__init__()方法是在创建对象后，就立刻被默认调用了 既然在创建完对象后__init__()方法已经被默认的执行了，那么能否让对象在调用__init__()方法的时候传递一些参数呢？如果可以，那怎样传递呢？ 1234567891011# 定义汽车类class Car: def __init__(self, newWheelNum, newColor): self.wheelNum = newWheelNum self.color = newColor def move(self): print('车在跑，目标:夏威夷')# 创建对象BMW = Car(4, 'green')print('车的颜色为:%s'%BMW.color)print('车轮子数量为:%d'%BMW.wheelNum) 总结 __init__()方法，在创建一个对象时默认被调用，不需要手动调用 __init__(self)中，默认有1个参数名字为self，如果在创建对象时传递了2个实参，那么__init__(self)中出了self作为第一个形参外还需要2个形参，例如__init__(self,x,y) __init__(self)中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递进去‘’ 魔法方法#先看一个例子 123456789class Cat: #属性 #方法 def eat(self): print(\"猫在吃鱼....\") def drink(self): print(\"猫正在喝kele.....\")cat =Cat()print(cat) 运行结果 123/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/day07/01-定义一个类.py&lt;__main__.Cat object at 0x100994048&gt;Process finished with exit code 0 直接打印某个对象，我们看到打印出来的是某个对象的地址 定义__str__()方法 1234567891011class Dog: def __init__(self,name,health,love,strain): self.name=name self.health=health self.love = love self.strain=strain def __str__(self): return \"狗狗的名字:%s,狗狗的亲密度%d,狗狗的健康值:%d,狗狗的品种:%s\"%(self.name,self.love,self.health,self.strain)dog =Dog(\"安倍晋三\",50,50,\"草狗\")print(dog) 运行结果 123/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test/Dog.py狗狗的名字:安倍晋三,狗狗的亲密度50,狗狗的健康值:50,狗狗的品种:草狗Process finished with exit code 0 总结 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据 self#1.理解self 1234567891011121314# 定义一个类class Animal: # 方法 def __init__(self, name): self.name = name def printName(self): print('名字为:%s'%self.name)# 定义一个函数def myPrint(animal): animal.printName()dog1 = Animal('草狗')myPrint(dog1)dog2 = Animal('狼狗')myPrint(dog2) 总结 所谓的self，可以理解为自己 可以把self当做C++中类里面的this指针一样理解，就是对象自身的意思 某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给self，所以开发者只需要传递后面的参数即可 面向对象案例1#为了更好的理解面向对象编程，下面以“烤地瓜”为案例，进行分析 1.分析“烤地瓜”的属性和方法 属性 cookedLevel : 这是数字；0~3表示还是生的，超过3表示半生不熟，超过5表示已经烤好了，超过8表示已经烤成木炭了！我们的地瓜开始时时生的 cookedString : 这是字符串；描述地瓜的生熟程度 condiments : 这是地瓜的配料列表，比如番茄酱、芥末酱等 方法 cook() : 把地瓜烤一段时间 addCondiments() : 给地瓜添加配料 __init__() : 设置默认的属性 __str__() : 让print的结果看起来更好一些 2.定义类和方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class SweetPotato: \"这是烤地瓜的类\" #定义初始化方法 def __init__(self): self.cookedLevel = 0 self.cookedString = \"生的\" self.condiments = [] #定制print时的显示内容 def __str__(self): msg = self.cookedString + \" 地瓜\" if len(self.condiments) &gt; 0: msg = msg + \"(\" for temp in self.condiments: msg = msg + temp + \", \" msg = msg.strip(\", \") msg = msg + \")\" return msg #烤地瓜方法 def cook(self, time): self.cookedLevel += time if self.cookedLevel &gt; 8: self.cookedString = \"烤成灰了\" elif self.cookedLevel &gt; 5: self.cookedString = \"烤好了\" elif self.cookedLevel &gt; 3: self.cookedString = \"半生不熟\" else: self.cookedString = \"生的\" #添加配料 def addCondiments(self, condiments): self.condiments.append(condiments)# 用来进行测试mySweetPotato = SweetPotato()print(\"------有了一个地瓜，还没有烤-----\")print(mySweetPotato.cookedLevel)print(mySweetPotato.cookedString)print(mySweetPotato.condiments)print(\"------接下来要进行烤地瓜了-----\")print(\"------地瓜经烤了4分钟-----\")mySweetPotato.cook(4) #烤4分钟print(mySweetPotato)print(\"------地瓜又经烤了3分钟-----\")mySweetPotato.cook(3) #又烤了3分钟print(mySweetPotato)print(\"------接下来要添加配料-番茄酱------\")mySweetPotato.addCondiments(\"番茄酱\")print(mySweetPotato)print(\"------地瓜又经烤了5分钟-----\")mySweetPotato.cook(5) #又烤了5分钟print(mySweetPotato)print(\"------接下来要添加配料-芥末酱------\")mySweetPotato.addCondiments(\"芥末酱\")print(mySweetPotato) 面向对象案例2#向一个房子中添加家具 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#定义一个home类class Home: def __init__(self, area): self.area = area #房间剩余的可用面积 #self.light = 'on' #灯默认是亮的 self.containsItem = [] def __str__(self): msg = \"当前房间可用面积为:\" + str(self.area) if len(self.containsItem) &gt; 0: msg = msg + \" 容纳的物品有: \" for temp in self.containsItem: msg = msg + temp.getName() + \", \" msg = msg.strip(\", \") return msg #容纳物品 def accommodateItem(self,item): #如果可用面积大于物品的占用面积 needArea = item.getUsedArea() if self.area &gt; needArea: self.containsItem.append(item) self.area -= needArea print(\"ok:已经存放到房间中\") else: print(\"err:房间可用面积为:%d,但是当前要存放的物品需要的面积为%d\"%(self.area, needArea))#定义bed类class Bed: def __init__(self,area,name = '床'): self.name = name self.area = area def __str__(self): msg = '床的面积为:' + str(self.area) return msg #获取床的占用面积 def getUsedArea(self): return self.area def getName(self): return self.name#创建一个新家对象newHome = Home(100)#100平米print(newHome)#创建一个床对象newBed = Bed(20)print(newBed)#把床安放到家里newHome.accommodateItem(newBed)print(newHome)#创建一个床对象newBed2 = Bed(30,'席梦思')print(newBed2)#把床安放到家里newHome.accommodateItem(newBed2)print(newHome) 总结 如果一个对象与另外一个对象有一定的关系，那么一个对象可以是另外一个对象的属性 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"Python基础(六)","slug":"python_base/python_06","date":"2018-05-07T09:41:10.000Z","updated":"2018-05-31T13:49:22.000Z","comments":true,"path":"2018/05/07/python_base/python_06/","link":"","permalink":"http://baofengketang.com/2018/05/07/python_base/python_06/","excerpt":"","text":"文件操作 文件介绍 文件的打开与关闭 文件读写 文件拷贝 文件的定位读写 文件的重命名、删除 文件夹的相关操作 批量修改文件名 文件操作#文件介绍#1.文件的作用 大家应该听说过一句话：“好记性不如烂笔头”。 不仅人的大脑会遗忘事情，计算机也会如此，比如一个程序在运行过程中用了九牛二虎之力终于计算出了结果，试想一下如果不把这些数据存放起来，相比重启电脑之后，“哭都没地方哭了” 可见，在把数据存储起来有做么大的价值 使用文件的目的： 就是把一些存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力 文件的打开与关闭#想一想： 如果想用word编写一份简历，应该有哪些流程呢？ 打开word软件，新建一个word文件 写入个人简历信息 保存文件 关闭word软件 同样，在操作文件的整体过程与使用word编写一份简历的过程是很相似的 打开文件，或者新建立一个文件 读/写数据 关闭文件 1.打开文件 在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件 open(文件名，访问模式) 示例如下： 1f = open('test.txt', 'w') 说明: 访问模式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 2.关闭文件 close( ) 示例如下： 1234# 新建一个文件，文件名为:test.txtf = open('test.txt', 'w')# 关闭这个文件f.close() 文件读写#1.写数据（write） 使用write()可以完成向文件写入数据 demo: 123f = open('/Users/jinzhong/hello.txt','w');f.write('helloworld,my name is jinzhong')f.close() 运行结果 注意： 如果文件不存在那么创建，如果存在那么就先清空，然后写入数据 2.读数据（read） 使用read(num)可以从文件中读取数据，num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据 demo: 123456f=open(\"hello.txt\",\"r\")content =f.read(5)print(content)content=f.read()print(content)f.close(); 运行结果 1234/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test11.pyhelloworld,my name is jinzhongProcess finished with exit code 0 注意： 如果open是打开一个文件，那么可以不用写打开的模式，即只写 open(&#39;test.txt&#39;) 如果使用读了多次，那么后面读取的数据是从上次读完后的位置开始的 3.读数据(readlines) 就像read没有参数时一样，readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素 123456789#coding=utf-8f = open('test.txt', 'r')content = f.readlines()print(type(content))i=1for temp in content: print(\"%d:%s\"%(i, temp)) i+=1f.close() 运行结果 12345678910111213141516171819/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test11.py&lt;class &apos;list&apos;&gt;1:helloworld,my name is jinzhong2:helloworld,my name is jinzhong3:helloworld,my name is jinzhong4:helloworld,my name is jinzhong5:helloworld,my name is jinzhong6:helloworld,my name is jinzhong7:helloworld,my name is jinzhong8:helloworld,my name is jinzhongProcess finished with exit code 0 4.读数据(readline) 1234567#coding=utf-8f = open('test.txt', 'r')content = f.readline()print(\"1:%s\"%content)content = f.readline()print(\"2:%s\"%content)f.close() 运行结果 1234/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test11.py&lt;class &apos;list&apos;&gt;1:helloworld,my name is jinzhong2:helloworld,my name is jinzhong 文件拷贝#123456789101112131415161718192021222324252627#coding=utf-8oldFileName = input(\"请输入要拷贝的文件名字:\")oldFile = open(oldFileName,'r')# 如果打开文件if oldFile: # 提取文件的后缀 fileFlagNum = oldFileName.rfind('.') if fileFlagNum &gt; 0: fileFlag = oldFileName[fileFlagNum:] # 组织新的文件名字 newFileName = oldFileName[:fileFlagNum] + '[复件]' + fileFlag # 创建新文件 newFile = open(newFileName, 'w') # 把旧文件中的数据，一行一行的进行复制到新文件中 for lineContent in oldFile.readlines(): newFile.write(lineContent) # 关闭文件 oldFile.close() newFile.close() 文件的定位读写#1.获取当前读写的位置 在读写文件的过程中，如果想知道当前的位置，可以使用tell()来获取 12345678910111213# 打开一个已经存在的文件f = open(\"hello.txt\", \"r\")str = f.read(3)print(\"读取的数据是 : \", str)# 查找当前位置position = f.tell()print (\"当前文件位置 : \", position)str = f.read(3)print (\"读取的数据是 : \", str)# 查找当前位置position = f.tell()print (\"当前文件位置 : \", position)f.close() 运行结果 /Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test12.py读取的数据是 : hel当前文件位置 : 3读取的数据是 : low当前文件位置 : 6 Process finished with exit code 0 2.定位到某个位置 如果在读写文件的过程中，需要从另外一个位置进行操作的话，可以使用seek() seek(offset, from)有2个参数 offset:偏移量 from:方向 0:表示文件开头 1:表示当前位置 2:表示文件末尾 demo:把位置设置为：从文件开头，偏移5个字节 12345678910111213# 打开一个已经存在的文件f = open(\"hello.txt\", \"r\")str = f.read(5)print(\"读取的数据是\",str)# 查找当前位置position = f.tell()print(\"当前文件位置是\",position)# 重新设置位置f.seek(10,0)# 查找当前位置position = f.tell()print(\"当前文件位置是\",position)f.close() demo:把位置设置为：离文件末尾 123456789101112# 打开一个已经存在的文件f = open(\"hello.txt\", \"r\")# 查找当前位置position = f.tell()print(\"当前文件位置是\",position)# 重新设置位置f.seek(0, 2)print(\"当前文件位置是\",position)# 读取到的数据为：文件最后3个字节数据str = f.read()print(\"读取的数据是：\",str)f.close() 文件的重命名、删除#有些时候，需要对文件进行重命名、删除等一些操作，python的os模块中都有这么功能 1.文件重命名 os模块中的rename()可以完成对文件的重命名操作 rename(需要修改的文件名, 新的文件名) 123import osos.rename(\"毕业论文.txt\", \"毕业论文-最终版.txt\") 2.删除文件 os模块中的remove()可以完成对文件的删除操作 remove(待删除的文件名) 12import osos.remove(\"毕业论文.txt\") 文件夹的相关操作#实际开发中，有时需要用程序的方式对文件夹进行一定的操作，比如创建、删除等 就像对文件操作需要os模块一样，如果要操作文件夹，同样需要os模块 1.创建文件夹 123import osos.mkdir(\"test\") 2.获取当前目录 12import osos.getcwd() 3.改变默认目录 12import osos.chdir(\"../\") 4.获取目录列表 12import osos.listdir(\"./\") 5.删除文件夹 12import osos.rmdir(\"test\") 批量修改文件名#参考代码 12345678910111213#coding=utf-8# 批量在文件名前加前缀import osfolderName = './test'# 获取指定路径的所有文件名字dirList = os.listdir(folderName)# 遍历输出所有文件名字for name in dirList: print (name) newName = '[sky]-' + name print (newName) os.rename(folderName+\"/\"+name, folderName+\"/\"+newName) 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"Python基础(五)","slug":"python_base/python_05","date":"2018-05-07T03:14:24.000Z","updated":"2018-05-31T13:49:23.000Z","comments":true,"path":"2018/05/07/python_base/python_05/","link":"","permalink":"http://baofengketang.com/2018/05/07/python_base/python_05/","excerpt":"","text":"函数 函数介绍 函数的定义与调用 函数的文档说明 函数参数（一） 函数返回值（一） 函数的类型 函数的嵌套调用 函数的应用 局部变量和全局变量 函数返回值（二） 函数参数（二） 递归函数 匿名函数 函数总结 自定义函数 调用函数 作用域 函数#函数介绍#什么是函数 先看如下代码 123456789101112131415161718192021222324252627282930print \" _ooOoo_ \" print \" o8888888o \" print \" 88 . 88 \" print \" (| -_- |) \" print \" O\\\\ = /O \" print \" ____/`---'\\\\____ \" print \" . ' \\\\| |// `. \" print \" / \\\\||| : |||// \\\\ \" print \" / _||||| -:- |||||- \\\\ \" print \" | | \\\\\\\\\\\\ - /// | | \" print \" | \\\\_| ''\\\\---/'' | | \" print \" \\\\ .-\\\\__ `-` ___/-. / \" print \" ___`. .' /--.--\\\\ `. . __ \" print \" .\"\" '&lt; `.___\\\\_&lt;|&gt;_/___.' &gt;'\"\". \" print \" | | : `- \\\\`.;`\\\\ _ /`;.`/ - ` : | | \" print \" \\\\ \\\\ `-. \\\\_ __\\\\ /__ _/ .-` / / \" print \" ======`-.____`-.___\\\\_____/___.-`____.-'====== \" print \" `=---=' \" print \" \" print \" ............................................. \" print \" 佛祖镇楼 BUG辟易 \" print \" 佛曰: \" print \" 写字楼里写字间，写字间里程序员； \" print \" 程序人员写程序，又拿程序换酒钱。 \" print \" 酒醒只在网上坐，酒醉还来网下眠； \" print \" 酒醉酒醒日复日，网上网下年复年。 \" print \" 但愿老死电脑间，不愿鞠躬老板前； \" print \" 奔驰宝马贵者趣，公交自行程序员。 \" print \" 别人笑我忒疯癫，我笑自己命太贱； \" print \" 不见满街漂亮妹，哪个归得程序员？\" 运行结果 想一想： 如果一个程序在不同的地方需要输出“佛祖镇楼”，程序应该怎样设计？ 12345678910&gt; if 条件1:&gt; 输出‘佛祖镇楼’&gt; &gt; ...(省略)...&gt; &gt; if 条件2:&gt; 输出‘佛祖镇楼’&gt; &gt; ...(省略)...&gt; 如果需要输出多次，是否意味着要编写这块代码多次呢？ 小总结: 如果在开发程序时，需要某块代码多次，但是为了提高编写的效率以及代码的重用，所以把具有独立功能的代码块组织为一个小模块，这就是函数 函数的定义与调用#定义函数 12def 函数名(): 代码 demo 12345# 定义一个函数，能够完成打印信息的功能 def printInfo(): print '------------------------------------' print ' 人生苦短，我用Python' print '------------------------------------' 调用函数 定义了函数之后，就相当于有了一个具有某些功能的代码，想要让这些代码能够执行，需要调用它 调用函数很简单的，通过 函数名() 即可完成调用 demo: 12# 定义完函数后，函数是不会自动执行的，需要调用它才可以 printInfo() 练一练 要求：定义一个函数，能够输出自己的姓名和年龄，并且调用这个函数让它执行 使用def定义函数 编写完函数之后，通过 函数名() 进行调用 函数的文档说明#1234567&gt;&gt;&gt; def test(a,b):... \"用来完成对2个数求和\"... print(\"%d\"%(a+b))... &gt;&gt;&gt; &gt;&gt;&gt; test(11,22)33 如果执行，以下代码 1&gt;&gt;&gt; help(test) 能够看到test函数的相关说明 12345Help on function test in module __main__:test(a, b) 用来完成对2个数求和(END) 函数参数（一）#思考一个问题，如下： 现在需要定义一个函数，这个函数能够完成2个数的加法运算，并且把结果打印出来，该怎样设计？下面的代码可以吗？有什么缺陷吗？ 123456&gt; def add2num():&gt; a = 11&gt; b = 22&gt; c = a+b&gt; print c&gt; 为了让一个函数更通用，即想让它计算哪两个数的和，就让它计算哪两个数的和，在定义函数的时候可以让函数接收数据，就解决了这个问题，这就是 函数的参数 1.定义一个带参数的函数 123def add2num(a, b): c = a+b print c 2.调用带参数的函数 以调用上面的add2num(a, b)函数为例: 1234def add2num(a, b): c = a+b print cadd2num(11, 22) #调用带有参数的函数时，需要在小括号中，传递数据 练一练 要求：定义一个函数，完成前2个数完成加法运算，然后对第3个数，进行减法；然后调用这个函数 使用def定义函数，要注意有3个参数 调用的时候，这个函数定义时有几个参数，那么就需要传递几个参数 3.调用函数时参数的顺序 12345678910111213&gt;&gt;&gt; def test(a,b):... print(a,b)... &gt;&gt;&gt; test(1,2)1 2&gt;&gt;&gt; test(b=1,a=2)2 1&gt;&gt;&gt; &gt;&gt;&gt; test(b=1,2) File \"&lt;stdin&gt;\", line 1SyntaxError: positional argument follows keyword argument&gt;&gt;&gt; &gt;&gt;&gt; 总结： 定义时小括号中的参数，用来接收参数用的，称为 “形参” 调用时小括号中的参数，用来传递给函数用的，称为 “实参” 函数返回值（一）#1、返回值介绍 现实生活中的场景: 我给儿子10块钱，让他给我买包烟。这个例子中，10块钱是我给儿子的，就相当于调用函数时传递到参数，让儿子买烟这个事情最终的目标是，让他把烟给你带回来然后给你对么，，，此时烟就是返回值 开发中的场景： 定义了一个函数，完成了获取室内温度，想一想是不是应该把这个结果给调用者，只有调用者拥有了这个返回值，才能够根据当前的温度做适当的调整 综上所述： 所谓“返回值”，就是程序中函数完成一件事情后，最后给调用者的结果 2、带返回值的函数 想要在函数中把结果返回给调用者，需要在函数中使用return 如下示例: 123def add2num(a, b): c = a+b return c 或者 12def add2num(a, b): return a+b 3、保存函数的返回值 刚刚买烟的例子中，最后儿子给你烟时，你一定是从儿子手中接过来 对么，程序也是如此，如果一个函数返回了一个数据，那么想要用这个数据，那么就需要保存 保存函数的返回值示例如下: 1234567#定义函数def add2num(a, b): return a+b#调用函数，顺便保存函数的返回值result = add2num(100,98)#因为result已经保存了add2num的返回值，所以接下来就可以使用了print result 函数的类型#函数根据有没有参数，有没有返回值，可以相互组合，一共有4种 无参数，无返回值 无参数，又反悔 有参数，无返回值 有参数，有返回值 1.无参数，无返回值的函数 此类函数，不能接收参数，也没有返回值，一般情况下，打印提示灯类似的功能，使用这类的函数 12345678def printMenu(): print('--------------------------') print(' xx涮涮锅 点菜系统') print('') print(' 1. 羊肉涮涮锅') print(' 2. 牛肉涮涮锅') print(' 3. 猪肉涮涮锅') print('--------------------------') 2.无参数，有返回值的函数 此类函数，不能接收参数，但是可以返回某个数据，一般情况下，像采集数据，用此类函数 1234567# 获取温度 def getTemperature(): #这里是获取温度的一些处理过程 #为了简单起见，先模拟返回一个数据 return 24 temperature = getTemperature() print('当前的温度为:%d'%temperature) 3.有参数，无返回值的函数 此类函数，能接收参数，但不可以返回数据，一般情况下，对某些变量设置数据而不需结果时，用此类函数 4.有参数，有返回值的函数 此类函数，不仅能接收参数，还可以返回某个数据，一般情况下，像数据处理并需要结果的应用，用此类函数 12345678910# 计算1~num的累积和 def calculateNum(num): result = 0 i = 1 while i&lt;=num: result = result + i i+=1 return result result = calculateNum(100) print('1~100的累积和为:%d'%result) 总结 函数根据有没有参数，有没有返回值可以相互组合 定义函数时，是根据实际的功能需求来设计的，所以不同开发人员编写的函数类型各不相同 函数的嵌套调用#123456789101112131415def testB(): print('---- testB start----') print('这里是testB函数执行的代码...(省略)...') print('---- testB end----') def testA(): print('---- testA start----') testB() print('---- testA end----') testA() 结果： 12345---- testA start-------- testB start----这里是testB函数执行的代码...(省略)...---- testB end-------- testA end---- 总结 一个函数里面又调用了另外一个函数，这就是所谓的函数嵌套调用 如果函数A中，调用了另外一个函数B，那么先把函数B中的任务都执行完毕之后才会回到上次 函数A执行的位置 函数的应用#练习1: 写一个函数打印一条横线 打印自定义行数的横线 123456789101112131415# 打印一条横线def printOneLine(): print(\"-\"*30)# 打印多条横线def printNumLine(num): i=0 # 因为printOneLine函数已经完成了打印横线的功能， # 只需要多次调用此函数即可 while i&lt;num: printOneLine() i+=1printNumLine(3) 练习2: 写一个函数求三个数的和 写一个函数求三个数的平均值 1234567891011121314# 求3个数的和def sum3Number(a,b,c): return a+b+c # return 的后面可以是数值，也可是一个表达式# 完成对3个数求平均值def average3Number(a,b,c): # 因为sum3Number函数已经完成了3个数的就和，所以只需调用即可 # 即把接收到的3个数，当做实参传递即可 sumResult = sum3Number(a,b,c) aveResult = sumResult/3.0 return aveResult# 调用函数，完成对3个数求平均值result = average3Number(11,2,55)print(\"average is %d\"%result) 局部变量和全局变量#1.局部变量 局部变量，就是在函数内部定义的变量 不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响 局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储，这就是它的作用 案例 123456def test(): a=100 print(a) a=200 print(a)test() 2.全局变量 如果一个变量，既能在一个函数中使用，也能在其他的函数中使用，这样的变量就是全局变量 案例 123456789# 定义全局变量a = 100def test1(): print(a)def test2(): print(a)# 调用函数test1()test2() 3.全局变量和局部变量相同问题 123456789a = 100def test1(): a =200 print(a)def test2(): a=300 print(a)# 调用函数test1() 优先访问局部变量 4.修改全局变量 1234567891011# 定义全局变量a = 100def test1(): global a a =200 print(a)def test2(): print(a)# 调用函数test1()test2() 4.总结 在函数外边定义的变量叫做全局变量 全局变量能够在所有的函数中进行访问 如果在函数中修改全局变量，那么就需要使用global进行声明，否则出错 如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量的 可变类型的局部变量 123456789101112131415161718192021&gt;&gt;&gt; a = 1&gt;&gt;&gt; def f():... a += 1... print a...&gt;&gt;&gt; f()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"&lt;stdin&gt;\", line 2, in fUnboundLocalError: local variable 'a' referenced before assignment&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; li = [1,]&gt;&gt;&gt; def f2():... li.append(1)... print li...&gt;&gt;&gt; f2()[1, 1]&gt;&gt;&gt; li[1, 1] 总结 在函数中不使用global声明全局变量时不能修改全局变量的本质是不能修改全局变量的指向，即不能将全局变量指向新的数据。 对于不可变类型的全局变量来说，因其指向的数据不能修改，所以不使用global时无法修改全局变量。 对于可变类型的全局变量来说，因其指向的数据可以修改，所以不使用global时也可修改全局变量。 函数返回值（二）#在函数中我们可不可以返回多个值 12345678910&gt;&gt;&gt; def divid(a, b):... shang = a//b... yushu = a%b ... return shang, yushu...&gt;&gt;&gt; sh, yu = divid(5, 2)&gt;&gt;&gt; sh5&gt;&gt;&gt; yu1 本质是利用了元组 函数参数（二）#1.缺省参数 调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入： 12345678def printinfo( name, age = 35 ): # 打印任何传入的字符串 print \"Name: \", name print \"Age \", age# 调用printinfo函数printinfo(name=\"miki\" )printinfo( age=9,name=\"miki\" ) 输出结果： 1234Name: mikiAge 35Name: mikiAge 9 注意：带有默认值的参数一定要位于参数列表的最后面。 12345&gt;&gt;&gt; def printinfo(name, age=35, sex):... print name... File \"&lt;stdin&gt;\", line 1SyntaxError: non-default argument follows default argument 2.不定长参数 有时可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，声明时不会命名。 基本语法如下： 1234def functionname([formal_args,] *args, **kwargs): \"函数_文档字符串\" function_suite return [expression] 加了星号（*）的变量args会存放所有未命名的变量参数，args为元组；而加**的变量kwargs会存放命名参数，即形如key=value的参数， kwargs为字典。 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; def fun(a, b, *args, **kwargs):... \"\"\"可变参数演示示例\"\"\"... print \"a =\", a... print \"b =\", b... print \"args =\", args... print \"kwargs: \"... for key, value in kwargs.items():... print key, \"=\", value...&gt;&gt;&gt; fun(1, 2, 3, 4, 5, m=6, n=7, p=8) # 注意传递的参数对应a = 1b = 2args = (3, 4, 5)kwargs: p = 8m = 6n = 7&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c = (3, 4, 5)&gt;&gt;&gt; d = &#123;\"m\":6, \"n\":7, \"p\":8&#125;&gt;&gt;&gt; fun(1, 2, *c, **d) # 注意元组与字典的传参方式a = 1b = 2args = (3, 4, 5)kwargs: p = 8m = 6n = 7&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fun(1, 2, c, d) # 注意不加星号与上面的区别a = 1b = 2args = ((3, 4, 5), &#123;'p': 8, 'm': 6, 'n': 7&#125;)kwargs:&gt;&gt;&gt;&gt;&gt;&gt; 3.引用传参 可变类型与不可变类型的变量分别作为函数参数时，会有什么不同吗？ Python有没有类似C语言中的指针传参呢？ 12345678910111213141516&gt;&gt;&gt; def selfAdd(a):... \"\"\"自增\"\"\"... a += a...&gt;&gt;&gt; a_int = 1&gt;&gt;&gt; a_int1&gt;&gt;&gt; selfAdd(a_int)&gt;&gt;&gt; a_int1&gt;&gt;&gt; a_list = [1, 2]&gt;&gt;&gt; a_list[1, 2]&gt;&gt;&gt; selfAdd(a_list)&gt;&gt;&gt; a_list[1, 2, 1, 2] Python中函数参数是引用传递（注意不是值传递）。对于不可变类型，因变量不能修改，所以运算不会影响到变量自身；而对于可变类型来说，函数体中的运算有可能会更改传入的参数变量。 想一想为什么 12345678910111213141516&gt;&gt;&gt; def selfAdd(a):... \"\"\"自增\"\"\"... a = a + a # 我们更改了函数体的这句话...&gt;&gt;&gt; a_int = 1&gt;&gt;&gt; a_int1&gt;&gt;&gt; selfAdd(a_int)&gt;&gt;&gt; a_int1&gt;&gt;&gt; a_list = [1, 2]&gt;&gt;&gt; a_list[1, 2]&gt;&gt;&gt; selfAdd(a_list)&gt;&gt;&gt; a_list[1, 2] # 想一想为什么没有变呢？ 递归函数#1.什么是递归函数 通过前面的学习知道一个函数可以调用其他函数。 如果一个函数在内部不调用其它的函数，而是自己本身的话，这个函数就是递归函数。 2.递归的作用 举个例子，我们来计算阶乘 n! = 1 * 2 * 3 * ... * n 解决办法1: 12345678910111213def getJieCheng(n): i=1 sum=1 while i&lt;=n: sum=sum*i i=i+1 return sumprint(getJieCheng(5))print(getJieCheng(4))print(getJieCheng(3))print(getJieCheng(2))print(getJieCheng(1)) 看阶乘的规律 1234561! = 12! = 2 × 1 = 2 × 1!3! = 3 × 2 × 1 = 3 × 2!4! = 4 × 3 × 2 × 1 = 4 × 3!...n! = n × (n-1)! 解决办法2: 123456789def getJieCheng2(n): if(n==1): return 1 else: return n*getJieCheng2(n-1)print(getJieCheng2(5))print(getJieCheng2(4))print(getJieCheng2(3))print(getJieCheng2(2)) 匿名函数#用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。 lambda函数的语法只包含一个语句，如下： 1lambda [arg1 [,arg2,.....argn]]:expression 如下实例： 1234sum = lambda arg1, arg2: arg1 + arg2#调用sum函数print \"Value of total : \", sum( 10, 20 )print \"Value of total : \", sum( 20, 20 ) 以上实例的输出结果 12Value of total : 30Value of total : 40 Lambda函数能接收任何数量的参数但只能返回一个表达式的值 匿名函数不能直接调用print，因为lambda需要一个表达式 应用场合 函数作为参数传递 1.自己定义函数 12345678910&gt; &gt;&gt;&gt; def fun(a, b, opt):&gt; ... print \"a =\", a&gt; ... print \"b =\", b&gt; ... print \"result =\", opt(a, b)&gt; ...&gt; &gt;&gt;&gt; fun(1, 2, lambda x,y:x+y)&gt; a = 1&gt; b = 2&gt; result = 3&gt; 2、作为内置函数的参数 想一想，下面的数据如何指定按age或name排序？ 123456&gt; stus = [&gt; &#123;\"name\":\"zhangsan\", \"age\":18&#125;, &gt; &#123;\"name\":\"lisi\", \"age\":19&#125;, &gt; &#123;\"name\":\"wangwu\", \"age\":17&#125;&gt; ]&gt; 按name排序： 12345&gt; &gt;&gt;&gt; stus.sort(key = lambda x:x['name'])&gt; &gt;&gt;&gt; stus&gt; [&#123;'age': 19, 'name': 'lisi'&#125;, &#123;'age': 17, 'name': 'wangwu'&#125;, &#123;'age': 18, 'name': 'zhangsan'&#125;]&gt; &gt; 按age排序 1234&gt; &gt;&gt;&gt; stus.sort(key = lambda x:x['age'])&gt; &gt;&gt;&gt; stus&gt; [&#123;'age': 17, 'name': 'wangwu'&#125;, &#123;'age': 18, 'name': 'zhangsan'&#125;, &#123;'age': 19, 'name': 'lisi'&#125;]&gt; 函数总结#自定义函数#1.无参数、无返回值 12def 函数名(): 语句 2.无参数、有返回值 123def 函数名(): 语句 return 需要返回的数值 注意: 一个函数到底有没有返回值，就看有没有return，因为只有return才可以返回数据 在开发中往往根据需求来设计函数需不需要返回值 函数中，可以有多个return语句，但是只要执行到一个return语句，那么就意味着这个函数的调用完成 3.有参数、无返回值 12def 函数名(形参列表): 语句 注意： 在调用函数时，如果需要把一些数据一起传递过去，被调用函数就需要用参数来接收 参数列表中变量的个数根据实际传递的数据的多少来确定 4.有参数，有返回值 123def 函数名(形参列表): 语句 return 需要返回的数值 注意：函数名不能同名 调用函数#调用的方式为： 1函数名([实参列表]) 调用时，到底写不写实参 如果调用的函数 在定义时有形参，那么在调用的时候就应该传递参数 调用时，实参的个数和先后顺序应该和定义函数中要求的一致 如果调用的函数有返回值，那么就可以用一个变量来进行保存这个值 作用域# 在一个函数中定义的变量，只能在本函数中用(局部变量) 在函数外定义的变量，可以在所有的函数中使用(全局变量) 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"Linux基础(一)","slug":"linux/linux_01","date":"2018-05-04T08:20:36.000Z","updated":"2018-06-14T07:35:39.000Z","comments":true,"path":"2018/05/04/linux/linux_01/","link":"","permalink":"http://baofengketang.com/2018/05/04/linux/linux_01/","excerpt":"","text":"Linux系统的发展史 Unix系统 Minix Liunx 总结 Linux系统的发展史#Unix系统#1965年之前的时候， 电脑并不像现在⼀样普遍， 它可不是⼀般⼈能碰的起的， 除⾮是军事或者学院的研究机构， ⽽且当时⼤型主机⾄多能提供30台终端（30个键盘、 显示器)， 连接⼀台电脑 为了解决数量不够⽤的问题，1965年左后由⻉尔实验室、 麻省理⼯学院以及通⽤电⽓共同发起了Multics项⽬， 想让⼤型主机⽀持300台终端 1969年前后这个项⽬进度缓慢， 资⾦短缺， ⻉尔实验室退出了研究 1969年从这个项⽬中退出的Ken Thompson当时在实验室⽆聊时， 为了让⼀台空闲的电脑上能够运⾏“星际旅⾏”游⾏， 在8⽉份左右趁着其妻⼦探亲的时间， ⽤了1个⽉的时间编写出了Unix操作系统的原型 1970年， 美国⻉尔实验室的 Ken Thompson， 以 BCPL语⾔ 为基础， 设计出很简单且很接近硬件的 B语⾔（取BCPL的⾸字⺟） ， 并且他⽤B语⾔写了第⼀个UNIX操作系统。因为B语⾔的跨平台性较差， 为了能够在其他的电脑上也能够运⾏这个⾮常棒的Unix操作系统， Dennis Ritchie和Ken Thompson 从B语⾔的基础上准备研究⼀个更好的语言 1972年， 美国⻉尔实验室的 Dennis Ritchie在B语⾔的基础上最终设计出了⼀种新的语⾔， 他取了BCPL的第⼆个字⺟作为这种语⾔的名字， 这就是C语⾔ 1973年初， C语⾔的主体完成。 Thompson和Ritchie迫不及待地开始⽤它完全重写了现在⼤名鼎鼎的Unix操作系统 Minix#因为AT&amp;T(通⽤电⽓)的政策改变， 在Version 7 Unix推出之后， 发布新的使⽤条款， 将UNIX源代码私有化， 在⼤学中不再能使⽤UNIX源代码。 Andrew S. Tanenbaum(塔能鲍姆)教授为了能在课堂上教授学⽣操作系统运作的实务细节， 决定在不使⽤任何AT&amp;T的源代码前提下， ⾃⾏开发与UNIX兼容的操作系统， 以避免版权上的争议。 他以⼩型UNIX（mini-UNIX） 之意， 将它称为MINIX(仅用于教学，不做商用) Liunx#因为Minix只是教学使⽤， 因此功能并不强， 因此Torvalds利⽤GNU的bash当做开发环境， gcc当做编译⼯具， 编写了Linux内核-v0.02， 但是⼀开始Linux并不能兼容Unix， 即Unix上跑的应⽤程序不能在Linux上跑， 即应⽤程序与内核之间的接⼝不⼀致， 因为Unix是遵循POSIX规范的， 因此Torvalds修改了Linux， 并遵循POSIX（Portable OperatingSystem Interface， 他规范了应⽤程序与内核的接⼝规范） ； ⼀开始Linux只适⽤于386，后来经过全世界的⽹友的帮助， 最终能够兼容多种硬件； 总结#Minix没有⽕起来的原因 Minix的创始⼈说， MINIX 3没有统治世界是源于他在1992年犯下的⼀个错误， 当时他认为BSD必然会⼀统天下， 因为它是⼀个更稳定和更成熟的系统， 其它操作系统难以与之竞争。 因此他的MINIX的重⼼集中在教育上。 四名BSD开发者已经成⽴了⼀家公司销售BSD系统， 他们甚⾄还有⼀个有趣的电话号码1-800-ITS-UNIX。 然⽽他们正因为这个电话号码⽽惹⽕上身。 美国电话电报公司因电话号码⽽提起诉讼。官司打了三年才解决。 在此期间， BSD陷于停滞， ⽽Linux则借此⼀⻜冲天。 他的错误在于没有意识官司竟然持续了如此⻓的时间， 以及BSD会因此受到削弱。 如果美国电话电报公司没有起诉， Linux永远不会流⾏起来， BSD将统治世界。 Linux现在版本__ 欢迎扫描我的微信，进行技术交流","categories":[{"name":"linux","slug":"linux","permalink":"http://baofengketang.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://baofengketang.com/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://baofengketang.com/tags/操作系统/"}]},{"title":"解决Ubuntu中vi命令的编辑模式下不能正常使用方向键和退格键的问题","slug":"vim/vim_02","date":"2018-05-04T02:43:05.000Z","updated":"2018-05-31T13:49:04.000Z","comments":true,"path":"2018/05/04/vim/vim_02/","link":"","permalink":"http://baofengketang.com/2018/05/04/vim/vim_02/","excerpt":"","text":"解决Ubuntu中vi命令的编辑模式下不能正常使用方向键和退格键的问题#在Ubuntu中，进入vi命令的编辑模式，发现按方向键不能移动光标，而是会输出ABCD，以及退格键也不能正常删除字符。这是由于Ubuntu预装的是vim-tiny，而我们需要使用vim-full，解决方法很简单，只需要以下两步： 步骤一，输入下述命令以卸载vim-tiny： 1sudo apt-get remove vim-common 步骤二，输入下述命令以安装vim-full： 1sudo apt-get install vim 现在在vi命令的编辑模式即可正常使用方向键和退格键。 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"vim","slug":"vim","permalink":"http://baofengketang.com/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://baofengketang.com/tags/vim/"},{"name":"编辑器","slug":"编辑器","permalink":"http://baofengketang.com/tags/编辑器/"}]},{"title":"Linux常用服务器构建-ftp服务器","slug":"linux/linux_06","date":"2018-05-03T09:22:14.000Z","updated":"2018-06-14T07:45:58.000Z","comments":true,"path":"2018/05/03/linux/linux_06/","link":"","permalink":"http://baofengketang.com/2018/05/03/linux/linux_06/","excerpt":"","text":"ftp服务器 ftp服务器#FTP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。 在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。 “下载”文件就是从远程主机拷贝文件至自己的计算机上； “上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。 1、安装vsftpd服务器 1sudo apt-get install vsftpd 2、配置vsftpd.conf文件 欢迎扫描我的微信，进行技术交流","categories":[{"name":"linux","slug":"linux","permalink":"http://baofengketang.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://baofengketang.com/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://baofengketang.com/tags/操作系统/"}]},{"title":"ubuntu软件安装与卸载","slug":"linux/linux_05","date":"2018-05-03T08:46:25.000Z","updated":"2018-06-14T07:45:49.000Z","comments":true,"path":"2018/05/03/linux/linux_05/","link":"","permalink":"http://baofengketang.com/2018/05/03/linux/linux_05/","excerpt":"","text":"更新Ubuntu软件下载地址 寻找国内镜像源 备份Ubuntu默认的源地址 更新源服务器列表 更新源 Ubuntu软件操作的相关命令 更新Ubuntu软件下载地址#寻找国内镜像源#所谓的镜像源：可以理解为提供下载软件的地方，比如Android手机上可以下载软件的91手机助手；iOS手机上可以下载软件的AppStore https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 注意：一定要选择好你的ubuntu的版本号 备份Ubuntu默认的源地址#1sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 更新源服务器列表#1vi sources.list 更新源#1sudo apt-get update 看到此图就表示成功了 Ubuntu软件操作的相关命令#12345678910111213141516171819202122232425262728293031sudo apt-get update 更新源sudo apt-get install package 安装包sudo apt-get remove package 删除包sudo apt-cache search package 搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package --reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package --purge 删除包，包括配置文件等sudo apt-get build-dep package 安装相关的编译环境sudo apt-get upgrade 更新已安装的包sudo apt-get dist-upgrade 升级系统sudo apt-cache depends package 了解使用该包依赖那些包sudo apt-cache rdepends package 查看该包被哪些包依赖sudo apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 欢迎扫描我的微信，进行技术交流","categories":[{"name":"linux","slug":"linux","permalink":"http://baofengketang.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://baofengketang.com/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://baofengketang.com/tags/操作系统/"}]},{"title":"Linux安装ssh服务","slug":"linux/linux_04","date":"2018-05-03T03:28:16.000Z","updated":"2018-06-14T07:45:41.000Z","comments":true,"path":"2018/05/03/linux/linux_04/","link":"","permalink":"http://baofengketang.com/2018/05/03/linux/linux_04/","excerpt":"","text":"过程： 最后： 过程：#1.检测是否已安装ssh服务，输入以下命令 1ssh localhost 出现以下提示则为未安装：ssh: connect to host localhost port 22: Connection refused（ssh：连接到主机本地主机端口22：连接被拒绝） 2.安装ssh-server 1$ sudo apt-get install openssh-server 3.启动服务 1$ sudo /etc/init.d/ssh start 启动成功会提示： [ ok ] Starting ssh (via systemctl): ssh.service. 4.检查服务是否启动成功 1$ ps -e|grep ssh 若有下面提示则启动成功6455 ? 00:00:00 sshd 最后：#启动、停止、重启SSH命令： 1$ sudo /etc/init.d/ssh start //启动SSH命令1 1$ sudo /etc/init.d/ss stop //停止SSH命令，重新连接你会发现不能再连接上了1 1$ sudo /etc/init.d/ss restart //重启SSH命令1 系统默认端口为22，修改可执行以下命令： 1$ sudo vim /etc/ssh/sshd_config1 找到 “# Port 22”改为 “Port 你想要的端口” (没有#号，#代表注释意思。) 例如→”Port 33”（前提得保证这个端口没有被占用）然后保存退出，再重启下服务即可生效 开启服务即刻在putty 连接，同时也可以通过sftp方式连接进行管理文件 卸载SSH服务: 123$ sudo /etc/init.d/ss stop$ sudo apt-get remove openssh-sftp-server //卸载sftp服务$ sudo apt-get remove openssh-server //卸载openssh-server服务 欢迎扫描我的微信，进行技术交流","categories":[{"name":"linux","slug":"linux","permalink":"http://baofengketang.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://baofengketang.com/tags/linux/"}]},{"title":"Linux基础(三)","slug":"linux/linux_03","date":"2018-05-03T01:56:59.000Z","updated":"2018-05-31T13:49:29.000Z","comments":true,"path":"2018/05/03/linux/linux_03/","link":"","permalink":"http://baofengketang.com/2018/05/03/linux/linux_03/","excerpt":"","text":"测试#","categories":[{"name":"linux","slug":"linux","permalink":"http://baofengketang.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://baofengketang.com/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://baofengketang.com/tags/操作系统/"}]},{"title":"Python基础(四)","slug":"python_base/python_04","date":"2018-04-23T09:44:50.000Z","updated":"2018-05-31T13:49:23.000Z","comments":true,"path":"2018/04/23/python_base/python_04/","link":"","permalink":"http://baofengketang.com/2018/04/23/python_base/python_04/","excerpt":"","text":"字符串、列表、元组、字典 字符串 字符串的表示 输出 输入 字符串中下标的使用 切片 字符串常见操作 列表介绍 基本使用 增删改查 列表的嵌套 元组 字典 字典的定义与使用 字典的常用操作(1) 字典的常用操作(2) 字典的遍历 公共方法 运算符 python内置函数 引用 字符串、列表、元组、字典#字符串#字符串的表示#在python中 使用双引号或者单引号中的数据，就是字符串 输出#12345print(\"hello\")print(\"hello\",\"world\")#输出多个参数print(\"hello\",end='')#输出后不换行print(\"python\")print(\"hello\",\"world\",sep=',')#使用逗号进行连接 案例： 123456789name = '张三'position = '南京'address = '南京市浦口区智芯大厦3楼南京网博'print('--------------------------------------------------')print(\"姓名：%s\"%name)print(\"职位：%s\"%position)print(\"公司地址：%s\"%address)print('--------------------------------------------------')print(\"姓名：%s\\n职位:%s\\n公司地址:%s\"%(name,position,address)) 输入#注意：input获取的数据，都以字符串的方式进行保存，即使输入的是数字，那么也是以字符串方式保存 1234userName = input('请输入用户名:')print(\"用户名为：%s\"%userName)password = input('请输入密码:')print(\"密码为：%s\"%password) 字符串中下标的使用#列表与元组支持下标索引好理解，字符串实际上就是字符的数组，所以也支持下标索引。 如果有字符串:name = ‘abcdef’，在内存中的实际存储如下: 如果想取出部分字符，那么可以通过下标的方法，（注意python中下标从 0 开始） 1234567&gt;&gt;&gt; name = 'abcdef'&gt;&gt;&gt; print(name[0])a&gt;&gt;&gt; print(name[1])b&gt;&gt;&gt; print(name[2])c 切片#切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作 切片的语法：[起始:结束:步长] 注意：选取的区间，即从”起始”位开始，到”结束”位的前一位结束（不包含结束位本身)。 我们以字符串为例讲解。 如果取出一部分，则可以在中括号[]中，使用: 123456789101112131415161718&gt;&gt;&gt; name'abcdef'&gt;&gt;&gt; print(name[0:3]) #取下标为0-2的字符abc&gt;&gt;&gt; print(name[3:5]) #取下标为3-4的字符de&gt;&gt;&gt; print(name[2:]) #取下标为2到最后的数据cdef&gt;&gt;&gt; print(name[1:-1])#取下标为1到倒数第二个的字符bcde&gt;&gt;&gt; a[:3]'abc'&gt;&gt;&gt; a[::2]'ace'&gt;&gt;&gt; a[::-2]'fdb'&gt;&gt;&gt; a[5:1:-2]'fd' 字符串常见操作#find 检测 str 中是否包含searchStr，如果是返回开始的索引值，否则返回-1 1mystr.find(searchStr, start=0, end=len(mystr)) index 跟find()方法一样，只不过如果searchStr不在 mystr中会报一个异常. 1mystr.index(searchStr, start=0, end=len(mystr)) count 返回 searchStr在start和end之间 在 mystr里面出现的次数 1mystr.count(searchStr, start=0, end=len(mystr)) replace 把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次 1mystr.replace(str1, str2, mystr.count(str1)) split 以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串 1mystr.split(str=\" \", 2) capitalize 把字符串的第一个字符大写 1mystr.capitalize() title 把字符串的每个单词首字母大写 startswith 检查字符串是否是以 obj 开头, 是则返回 True，否则返回 False 1mystr.startswith(obj) 1234567&gt;&gt;&gt; str =\"helloworld\"&gt;&gt;&gt; str'helloworld'&gt;&gt;&gt; str.startswith('hello')True&gt;&gt;&gt; str.startswith('helle')False endswith 检查字符串是否以obj结束，如果是返回True,否则返回 False. 1mystr.endswith(obj) lower 转换 mystr 中所有大写字符为小写 1mystr.lower() upper 转换mystr中的的小写字母为大写 ljust 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 1mystr.rjust(width) 案例： 123&gt;&gt;&gt; str = \"hello\"&gt;&gt;&gt; str.ljust(10)'hello ' rjust 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 1mystr.rjust(width) 案例： 123&gt;&gt;&gt; str =\"hello\"&gt;&gt;&gt; str.rjust(10);' hello' center 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串 1mystr.center(width) 案例： 1234&gt;&gt;&gt; str'hello'&gt;&gt;&gt; str.center(10)' hello ' lstrip 删除 mystr 左边的空白字符 1mystr.lstrip() 案例 123&gt;&gt;&gt; str =\" helloworld \";&gt;&gt;&gt; str.lstrip();'helloworld ' rstrip 删除 mystr 字符串末尾的空白字符 1mystr.rstrip() 案例 1234&gt;&gt;&gt; str' helloworld '&gt;&gt;&gt; str.rstrip()' helloworld' strip 删除mystr字符串两端的空白字符 1234567&gt;&gt;&gt; str=&quot;\\n\\thello\\t\\n&quot;&gt;&gt;&gt; print(str) hello &gt;&gt;&gt; str.strip();&apos;hello&apos; rfind 类似于 find()函数，不过是从右边开始查找. 1mystr.rfind(str, start=0,end=len(mystr) ) 案例： 123&gt;&gt;&gt; str=\"helloworldhello\";&gt;&gt;&gt; str.rfind('hello');10 rindex 类似于 index()，不过是从右边开始. 1mystr.rindex( str, start=0,end=len(mystr)) 案例 1234&gt;&gt;&gt; str'helloworldhello'&gt;&gt;&gt; str.rindex('hello')10 partition 把mystr以str分割成三部分,str前，str和str后 1mystr.partition(str) 案例： 1234&gt;&gt;&gt; str'helloworldhello'&gt;&gt;&gt; str.partition(\"hello\")('', 'hello', 'worldhello') rpartition 类似于 partition()函数,不过是从右边开始. 1mystr.rpartition(str) 案例 12345&gt;&gt;&gt; str=\"hello kingdom worldkingdom skapps\";&gt;&gt;&gt; str.partition('kingdom')('hello ', 'kingdom', ' worldkingdom skapps')&gt;&gt;&gt; str.rpartition('kingdom')('hello kingdom world', 'kingdom', ' skapps') splitlines 按照行分隔，返回一个包含各行作为元素的列表 1mystr.splitlines() 12345&gt;&gt;&gt; str=\"hello\\nworld\\nhelloworld\\nkingdom\"&gt;&gt;&gt; str'hello\\nworld\\nhelloworld\\nkingdom'&gt;&gt;&gt; str.splitlines()['hello', 'world', 'helloworld', 'kingdom'] isalpha 如果 mystr 所有字符都是字母 则返回 True,否则返回 False 1mystr.isalpha() 123456789&gt;&gt;&gt; str=\"abc\"&gt;&gt;&gt; str.isalpha();True&gt;&gt;&gt; str=\"123\"&gt;&gt;&gt; str.isalpha();False&gt;&gt;&gt; str=\"abc123\"&gt;&gt;&gt; str.isalpha()False isdigit 如果 mystr 只包含数字则返回 True 否则返回 False. 1mystr.isdigit() 案例 123456789&gt;&gt;&gt; str=\"123\"&gt;&gt;&gt; str.isdigit()True&gt;&gt;&gt; str=\"abc\"&gt;&gt;&gt; str.isdigit();False&gt;&gt;&gt; str=\"123abc\";&gt;&gt;&gt; str.isdigit();False isalnum 如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False 1mystr.isalnum() 案例： 123456789101112&gt;&gt;&gt; str=\"123\"&gt;&gt;&gt; str.isalnum()True&gt;&gt;&gt; str=\"abc\"&gt;&gt;&gt; str.isalnum()True&gt;&gt;&gt; str=\"123abc\"&gt;&gt;&gt; str.isalnum()True&gt;&gt;&gt; str=\"123abc hello\\t\";&gt;&gt;&gt; str.isalnum();False isspace 如果 mystr 中只包含空格，则返回 True，否则返回 False. 1mystr.isspace() 案例 123456789101112&gt;&gt;&gt; str=\" \"&gt;&gt;&gt; str.isspace()True&gt;&gt;&gt; str=\"hello kingdom\"&gt;&gt;&gt; str.isspace()False&gt;&gt;&gt; str=\"\\t\"&gt;&gt;&gt; str.isspace()True&gt;&gt;&gt; str=\"\\n\"&gt;&gt;&gt; str.isspace()True join mystr 中每个字符后面插入str,构造出一个新的字符串 1mystr.join(str) 案例 123456789&gt;&gt;&gt; str =\"\"&gt;&gt;&gt; names=[\"jinzhong\",\"xiaot\",\"sky\"]&gt;&gt;&gt; str.join(names)'jinzhongxiaotsky'&gt;&gt;&gt; str''&gt;&gt;&gt; str=\"_\"&gt;&gt;&gt; str.join(names);'jinzhong_xiaot_sky' 列表介绍#基本使用#Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 比如，列出班里所有同学的名字，就可以用一个list表示： 123&gt;&gt;&gt; names=[\"zhangsan\",\"lisi\",\"wangwu\"];&gt;&gt;&gt; names['zhangsan', 'lisi', 'wangwu'] 变量names就是一个list。用len()函数可以获得list元素的个数： 12&gt;&gt;&gt; len(names)3 用索引来访问list中每一个位置的元素，记得索引是从0开始的,如果超出索引会报越界异常 123456789101112&gt;&gt;&gt; names['zhangsan', 'lisi', 'wangwu']&gt;&gt;&gt; names[0]'zhangsan'&gt;&gt;&gt; names[1]'lisi'&gt;&gt;&gt; names[2]'wangwu'&gt;&gt;&gt; names[3]Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;IndexError: list index out of range 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素： 123456789101112&gt;&gt;&gt; names['zhangsan', 'lisi', 'wangwu']&gt;&gt;&gt; names[-1]'wangwu'&gt;&gt;&gt; names[-2]'lisi'&gt;&gt;&gt; names[-3]'zhangsan'&gt;&gt;&gt; names[-4]Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;IndexError: list index out of range 当然，倒数第4个就越界了。 注意：在python中列表中可以放多种不同的数据类型，比如 123&gt;&gt;&gt; mytypes=[1,2,3,4,\"hello\"];&gt;&gt;&gt; mytypes[1, 2, 3, 4, 'hello'] 使用for循环来迭代列表 12345678&gt;&gt;&gt; names['jinzhong', 'xiaot', 'sky']&gt;&gt;&gt; for name in names:... print(name)... jinzhongxiaotsky 使用while循环来迭代列表 123456names=[\"zhangsan\",\"lisi\",\"wagnwu\"]length=len(names)i=0while i&lt;length: print(names[i]) i=i+1 运行结果 12345/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/list.pyzhangsanlisiwagnwuProcess finished with exit code 0 增删改查#增加 list是一个可变的有序表，所以，可以往list中追加元素到末尾： 12345&gt;&gt;&gt; names['zhangsan', 'lisi', 'wangwu']&gt;&gt;&gt; names.append(\"zhaoliu\")&gt;&gt;&gt; names['zhangsan', 'lisi', 'wangwu', 'zhaoliu'] 总结：append方法是向列表最后插入 也可以把元素插入到指定的位置，比如索引号为1的位置： 12345&gt;&gt;&gt; names['zhangsan', 'lisi', 'wangwu', 'zhaoliu']&gt;&gt;&gt; names.insert(1,\"helloworld\")&gt;&gt;&gt; names['zhangsan', 'helloworld', 'lisi', 'wangwu', 'zhaoliu'] 总结：insert方法是在列表指定位置插入insert(index,”带插入字符串”) 2个列表也可以进行合并,使用+号 12345&gt;&gt;&gt; names1=[\"zhangsan\",\"lisi\"];&gt;&gt;&gt; names2=[\"wangwu\",\"zhaoliu\"];&gt;&gt;&gt; names3=names1+names2&gt;&gt;&gt; names3['zhangsan', 'lisi', 'wangwu', 'zhaoliu'] +号是将2个列表合并,也可以使用另外一个方法：extends 1234567&gt;&gt;&gt; names1['zhangsan', 'lisi']&gt;&gt;&gt; names2['wangwu', 'zhaoliu']&gt;&gt;&gt; names1.extend(names2);&gt;&gt;&gt; names1['zhangsan', 'lisi', 'wangwu', 'zhaoliu'] 删除 要删除list末尾的元素，用pop()方法： 12345['zhangsan', 'lisi', 'wangwu', 'zhaoliu']&gt;&gt;&gt; names1.pop();'zhaoliu'&gt;&gt;&gt; names1['zhangsan', 'lisi', 'wangwu'] 删除指定的元素 remove 12345&gt;&gt;&gt; names1['zhangsan', 'wangwu', 'zhangsan']&gt;&gt;&gt; names1.remove('zhangsan');&gt;&gt;&gt; names1['wangwu', 'zhangsan'] remove只列表中指定的一个，多余的不会删除 按照索引删除，列表也支持切片和索引del 123456789101112131415161718'zhangsan'&gt;&gt;&gt; name&gt;&gt;&gt; names3['zhangsan', 'lisi', 'wangwu', 'zhaoliu']&gt;&gt;&gt; names3[0]'zhangsan'&gt;&gt;&gt; names3[1]'lisi'&gt;&gt;&gt; names3[2]'wangwu'&gt;&gt;&gt; names3[3]'zhaoliu'&gt;&gt;&gt; names3[0:3]['zhangsan', 'lisi', 'wangwu']&gt;&gt;&gt; del names3[0]&gt;&gt;&gt; names3['lisi', 'wangwu', 'zhaoliu']&gt;&gt;&gt; 修改 直接采用下标进行修改 1234['lisi', 'wangwu', 'zhaoliu']&gt;&gt;&gt; names3[0]=\"hahaha\"&gt;&gt;&gt; names3['hahaha', 'wangwu', 'zhaoliu'] 查询 所谓的查找，就是看看指定的元素是否存在 in, not in python中查找的常用方法为： in（存在）,如果存在那么结果为true，否则为false not in（不存在），如果不存在那么结果为true，否则false demo 1234567nameList = ['zhangsan','lisi','wangwu']findName = input('请输入要查找的姓名:')if findName in nameList: print('在字典中找到了相同的名字')else: print('没有找到') index,count index和count与字符串中的用法相同 12345a = ['a', 'b', 'c', 'a', 'b']print(a.index('a',1,4))#返回3print(a.count('b'))# 返回2print(a.count('d'))#返回0print(a) 列表排序和反转 sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse=True可改为倒序，由大到小。 reverse方法是将list逆置。 案例： 12345678a = [1, 4, 2, 3]print(a)a.reverse()print(a)a.sort()print(a)a.sort(reverse=True)print(a) 运行结果 123456/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test06.py[1, 4, 2, 3][3, 2, 4, 1][1, 2, 3, 4][4, 3, 2, 1]Process finished with exit code 0 列表的嵌套#类似while循环的嵌套，列表也是支持嵌套的 一个列表中的元素又是一个列表，那么这就是列表的嵌套 123schoolNames = [['北京大学','清华大学'], ['南开大学','天津大学','天津师范大学'], ['山东大学','中国海洋大学']] 案例 一个学校，有3个办公室，现在有8位老师等待工位的分配，请编写程序，完成随机的分配 12345678910111213141516#encoding=utf-8import randomoffice=[[],[],[]];names=[\"金大中老师\",\"朴槿惠老师\",\"王利群老师\",\"红南京老师\",\"金南京老师\",\"紫南京老师\",\"大前门老师\",\"七彩梦度老师\"];i=0;while i &lt;len(names): randomNum=random.randint(0,2) office[randomNum].append(names[i]) i=i+1i=1;for temps in office: print(\"办公室%d的人数为%d\"%(i,len(temps))) for temp in temps: print(temp,end=\"\\t\") i=i+1 print() 运行结果： 1234567/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test07.py办公室1的人数为1朴槿惠老师 办公室2的人数为3金南京老师 紫南京老师 七彩梦度老师 办公室3的人数为4金大中老师 王利群老师 红南京老师 大前门老师 元组#Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。 12aTuple = ('et',77,99.9)print(aTuple) 访问元组 1234aTuple = ('et',77,99)print(aTuple[0])print(aTuple[1])print(aTuple[2]) 修改元组 python中不允许修改元组的数据，包括不能删除其中的元素。 1234567&gt;&gt;&gt; a=('a','b','c')&gt;&gt;&gt; a('a', 'b', 'c')&gt;&gt;&gt; a[0]='hello'Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment 元组中的内置函数count,index index和count与字符串和列表中的用法相同 123456&gt;&gt;&gt; a('a', 'b', 'c')&gt;&gt;&gt; a.index('a')0&gt;&gt;&gt; a.count('b')1 元祖遍历 1234&gt;&gt;&gt; a_turple = (1, 2, 3, 4, 5)&gt;&gt;&gt; for num in a_turple:... print(num,end=\" \")1 2 3 4 5 字典#字典的定义与使用#1info = &#123;'name':'班长', 'id':100, 'sex':'f', 'address':'地球亚洲中国北京'&#125; 说明： 字典和列表一样，也能够存储多个数据 列表中找某个元素时，是根据下标进行的 字典中找某个元素时，是根据’名字’（就是冒号:前面的那个值，例如上面代码中的’name’、’id’、’sex’） 字典的每个元素由2部分组成，键:值。例如 ‘name’:’班长’ ,’name’为键，’班长’为值 根据键访问值 123info = &#123;'name':'班长', 'id':100, 'sex':'f', 'address':'地球亚洲中国北京'&#125;print(info['name'])print(info['address']) 若访问不存在的键，则会报错： 1234&gt;&gt;&gt; info['age']Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;KeyError: 'age' 在我们不确定字典中是否存在某个键而又想获取其值时，可以使用get方法，还可以设置默认值： 1234567&gt;&gt;&gt; age = info.get('age')&gt;&gt;&gt; age #'age'键不存在，所以age为None&gt;&gt;&gt; type(age)&lt;type 'NoneType'&gt;&gt;&gt;&gt; age = info.get('age', 18) # 若info中不存在'age'这个键，就返回默认值18&gt;&gt;&gt; age18 字典的常用操作(1)#修改元素 字典的每个元素中的数据是可以修改的，只要通过key找到，即可修改 demo: 12345info = &#123;'name': '班长', 'id': 100, 'sex': 'f', 'address': '地球亚洲中国北京'&#125;print(info)newId = input('请输入新的学号')info['id'] = int(newId)print(info) 结果: 12345/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test09.py&#123;&apos;name&apos;: &apos;班长&apos;, &apos;id&apos;: 100, &apos;sex&apos;: &apos;f&apos;, &apos;address&apos;: &apos;地球亚洲中国北京&apos;&#125;请输入新的学号1001&#123;&apos;name&apos;: &apos;班长&apos;, &apos;id&apos;: 1001, &apos;sex&apos;: &apos;f&apos;, &apos;address&apos;: &apos;地球亚洲中国北京&apos;&#125;Process finished with exit code 0 添加元素 demo:访问不存在的元素 123456&gt;&gt;&gt; infos&#123;'id': '1001', 'name': 'zhangsan', 'age': 15&#125;&gt;&gt;&gt; print(\"地址%s\"%infos['addr'])Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;KeyError: 'addr' 如果在使用 变量名[‘键’] = 数据 时，这个“键”在字典中，不存在，那么就会新增这个元素 demo:添加新的元素 1234info = &#123;'name':'班长', 'sex':'f', 'address':'地球亚洲中国北京'&#125;newId = input('请输入新的学号')info['id'] = newIdprint('添加之后的id为:%s'%info['id']) 删除元素 对字典进行删除操作，有一下几种： del clear() demo:del删除指定的元素 1234info = &#123;'name':'班长', 'sex':'f', 'address':'地球亚洲中国北京'&#125;print('删除前,%s'%info['name'])del info['name']print('删除后,%s'%info['name']) 结果 1234/Users/jinzhong/PycharmProjects/hello3/venv/bin/python /Users/jinzhong/PycharmProjects/hello3/demo/test10.py删除前,&#123;&apos;name&apos;: &apos;班长&apos;, &apos;sex&apos;: &apos;f&apos;, &apos;address&apos;: &apos;地球亚洲中国北京&apos;&#125;删除后,&#123;&apos;sex&apos;: &apos;f&apos;, &apos;address&apos;: &apos;地球亚洲中国北京&apos;&#125;Process finished with exit code 0 demo:del删除整个字典，字典将无法访问到了 1234info = &#123;'name':'monitor', 'sex':'f', 'address':'China'&#125;print('删除前,%s'%info)del infoprint('删除后,%s'%info) demo:clear清空整个字典,只是清空内容 1234info = &#123;'name':'monitor', 'sex':'f', 'address':'China'&#125;print('清空前,%s'%info)info.clear()print('清空后,%s'%info) 字典的常用操作(2)#len() 测量字典中，键值对的个数 12345&gt;&gt;&gt; dict=&#123;\"name\":\"zhangsan\",\"age\":15&#125;&gt;&gt;&gt; dict&#123;'name': 'zhangsan', 'age': 15&#125;&gt;&gt;&gt; len(dict)2 keys 返回一个包含字典所有key的列表 1234&gt;&gt;&gt; dict&#123;'name': 'zhangsan', 'age': 15&#125;&gt;&gt;&gt; dict.keys()dict_keys(['name', 'age']) values 返回一个字典所有value的列表 1234&gt;&gt;&gt; dict&#123;'name': 'zhangsan', 'age': 15&#125;&gt;&gt;&gt; dict.keys()dict_keys(['name', 'age']) items 返回一个包含所有（键，值）元祖的列表 1234&gt;&gt;&gt; dict&#123;'name': 'zhangsan', 'age': 15&#125;&gt;&gt;&gt; dict.items()dict_items([('name', 'zhangsan'), ('age', 15)]) has_key dict.has_key(key)如果key在字典中，返回true，否则返回false(python2中起作用) 12345&gt;&gt;&gt; dict=&#123;\"name\":\"zhangsan\",\"age\":\"14\"&#125;&gt;&gt;&gt; dict.has_key('name')True&gt;&gt;&gt; dict.has_key('addr')False 字典的遍历#遍历字典的key（键） 123info = &#123;'name':'monitor', 'sex':'f', 'address':'China'&#125;for key in info.keys(): print(key) 遍历字典中的value 123info = &#123;'name':'monitor', 'sex':'f', 'address':'China'&#125;for val in info.values(): print(val) 遍历字典中的项 123info = &#123;'name':'monitor', 'sex':'f', 'address':'China'&#125;for item in info.items(): print(item) 遍历字典中的键值对 123info = &#123;'name':'monitor', 'sex':'f', 'address':'China'&#125;for key,value in info.items(): print(\"键：%s,值:%s\"%(key,value)) 实现带下标索引的遍历 12345infos = [\"zhangsan\",\"lisi\",\"wangwu\",\"zhaoliu\"]i=1;for info in infos: print(\"编号:%d,内容%s\"%(i,info)) i=i+1 enumerate() 123infos = [\"zhangsan\",\"lisi\",\"wangwu\",\"zhaoliu\"]for i,info in enumerate(infos): print(\"编号:%d,内容%s\" % (i, info)) 迭代效果如下 1234编号:0,内容zhangsan编号:1,内容lisi编号:2,内容wangwu编号:3,内容zhaoliu 公共方法#运算符# 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * ‘Hi!’ * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 复制 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 + 123456&gt;&gt;&gt; \"hello\"+\"world\"'helloworld'&gt;&gt;&gt; ['1','2']+['3','4']['1', '2', '3', '4']&gt;&gt;&gt; ('a','b')+('c','d')('a', 'b', 'c', 'd') * 123456&gt;&gt;&gt; 'ab'*4'abababab'&gt;&gt;&gt; [1,2]*4[1, 2, 1, 2, 1, 2, 1, 2]&gt;&gt;&gt; (1,2)*3(1, 2, 1, 2, 1, 2) in 123456&gt;&gt;&gt; 3 in [1,2]False&gt;&gt;&gt; 4 in [1,2,3,5,4]True&gt;&gt;&gt; \"name\" in &#123;\"name\":\"zhangsan\",\"age\":15&#125;True 注意：in在对字典操作时，判断的是字典的键 python内置函数#Python包含了以下内置函数 序号 方法 描述 1 cmp(item1, item2) 比较两个值 2 len(item) 计算容器中元素个数 3 max(item) 返回容器中元素最大值 4 min(item) 返回容器中元素最小值 5 del(item) 删除变量 cmp 该函数只能在python2 中使用 1234567891011121314151617&gt;&gt;&gt; cmp(\"hello\",\"world\")-1&gt;&gt;&gt; cmp(\"world\",\"hello\")1&gt;&gt;&gt; cmp(\"hello\",\"hello\")0&gt;&gt;&gt; cmp([1,2],[3,4])-1&gt;&gt;&gt; cmp([1,2],[1,1])1&gt;&gt;&gt; cmp([1,2],[1,2])0&gt;&gt;&gt; cmp(&#123;\"a\":1&#125;,&#123;\"b\":1&#125;)-1&gt;&gt;&gt; cmp(&#123;\"a\":1&#125;,&#123;\"a\":1&#125;)0&gt;&gt;&gt; cmp(&#123;\"a\":1&#125;,&#123;\"a\":2&#125;) 注意：cmp在比较字典数据时，先比较键，在比较值 len 123456&gt;&gt;&gt; len([1,2,3,4])4&gt;&gt;&gt; len((1,2,3))3&gt;&gt;&gt; len(&#123;\"name\":\"zhangsan\",\"age\":15,\"addr\":\"nanjing\"&#125;)3 注意:len在操作字典数据时，返回的是键值对的个数 max 1234567&gt;&gt;&gt; max(\"helloworld\")'w'&gt;&gt;&gt; max([1,2,3,4,5])5&gt;&gt;&gt; max(&#123;\"a\":1,\"b\":2&#125;)'b'&gt;&gt;&gt; max(&#123;\"a\":10,\"b\":1&#125;) del 有两种用法，一种是del加空格，另一种是del() 123456789101112131415&gt;&gt;&gt; a=1&gt;&gt;&gt; del a&gt;&gt;&gt; aTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'a' is not defined&gt;&gt;&gt; a=[\"hello\",\"world\",\"sky\",\"moon\"]&gt;&gt;&gt; del a[0]&gt;&gt;&gt; a['world', 'sky', 'moon']&gt;&gt;&gt; del(a)&gt;&gt;&gt; aTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'a' is not defined 补充：多维列表、元祖访问 123456789101112&gt;&gt;&gt; tup1=[(1,2),(3,4)]&gt;&gt;&gt; tup1[0][0]1&gt;&gt;&gt; tup1[0][1]2&gt;&gt;&gt; tup1[1][0]3&gt;&gt;&gt; tup1[1][1]4&gt;&gt;&gt; tup2=tup1+[(5,6)]&gt;&gt;&gt; tup2[(1, 2), (3, 4), (5, 6)] 引用#想一想 1234567&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = a&gt;&gt;&gt; b1&gt;&gt;&gt; a = 2&gt;&gt;&gt; a2 请问此时b的值是多少 1234567&gt;&gt;&gt; a = [1, 2]&gt;&gt;&gt; b = a&gt;&gt;&gt; b[1, 2]&gt;&gt;&gt; a.append(3)&gt;&gt;&gt; a[1, 2, 3] 请问此时b的值又是多少 引用 在python中，值是靠引用来传递来的。我们可以用id()来判断两个变量是否为同一个值的引用。 我们可以将id值理解为那块内存的地址标示。 1234567891011&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = a&gt;&gt;&gt; id(a) 13033816&gt;&gt;&gt; id(b) # 注意两个变量的id值相同13033816&gt;&gt;&gt; a = 2&gt;&gt;&gt; id(a) # 注意a的id值已经变了13033792&gt;&gt;&gt; id(b) # b的id值依旧13033816 12345678910111213&gt;&gt;&gt; a = [1, 2]&gt;&gt;&gt; b = a&gt;&gt;&gt; id(a)139935018544808&gt;&gt;&gt; id(b)139935018544808&gt;&gt;&gt; a.append(3)&gt;&gt;&gt; a[1, 2, 3]&gt;&gt;&gt; id(a)139935018544808&gt;&gt;&gt; id(b) # 注意a与b始终指向同一个地址139935018544808 可变类型与不可变类型 可变类型，值可以改变： 列表 list 字典 dict 不可变类型，值不可以改变： 数值类型 int, long, bool, float 字符串 str 元组 tuple 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"Python基础(三)","slug":"python_base/python_03","date":"2018-04-23T08:23:30.000Z","updated":"2018-05-31T13:49:24.000Z","comments":true,"path":"2018/04/23/python_base/python_03/","link":"","permalink":"http://baofengketang.com/2018/04/23/python_base/python_03/","excerpt":"","text":"流程控制 分支结构 基本if if…else elif的功能(多重if) 嵌套if 循环结构 while循环 for循环 break和continue 巩固练习 流程控制#分支结构#基本if#12if 要判断的条件: 条件成立时，要做的事情 案例 1234gradestr=input(\"请输入你的等级：\");grade =int(gradestr);if grade&gt;=4: print('等级大于4级，可以出去浪'); 小结：代码的缩进为一个tab键，或者4个空格 练一练 从键盘获取自己的年龄，判断是否大于或者等于18岁，如果满足就输出“哥，已成年，网吧可以去了“ 使用input从键盘中获取数据，并且存入到一个变量中使用if语句，来判断 age&gt;=18是否成立 if…else#12345678910if 条件: 满足条件时要做的事情1 满足条件时要做的事情2 满足条件时要做的事情3 ...(省略)...else: 不满足条件时要做的事情1 不满足条件时要做的事情2 不满足条件时要做的事情3 ...(省略)... 案例： 123456gradestr=input(\"请输入你的等级：\");grade =int(gradestr);if grade&gt;=4: print('等级大于4级，可以出去浪');else : print('猥琐发育，别浪！！！'); 练一练： 要求：从键盘输入露娜的考试成绩，如果大于等于100分，可以释放无限连，否则，好好练习微操作 elif的功能(多重if)#12345678if xxx1: 事情1elif xxx2: 事情2elif xxx3: 事情3else: 事情4 案例： 12345678910scorestr=input(\"请输入你的考试分数：\");score =int(scorestr);if score&gt;90: print('奖励苹果笔记本一台');elif score&gt;80: print('奖励iphone5一个');elif score&gt;70: print('奖励音像一个');else: print('洗洗回家睡觉'); 嵌套if#需求： 坐火车或者地铁的实际情况是：先进行安检如果安检通过才会判断是否有车票，或者是先检查是否有车票之后才会进行安检，即实际的情况某个判断是再另外一个判断成立的基础上进行的，这样的情况该怎样解决呢？－&gt;嵌套if if嵌套的格式： 12345678if 条件1: 满足条件1 做的事情1 满足条件1 做的事情2 ...(省略)... if 条件2: 满足条件2 做的事情1 满足条件2 做的事情2 ...(省略)... 说明 外层的if判断，也可以是if-else 内层的if判断，也可以是if-else 根据实际开发的情况，进行选择 案例： 12345678910111213chePiao = 1 # 用1代表有车票，0代表没有车票daoLenght = 9 # 刀子的长度，单位为cmif chePiao == 1: print(\"有车票，可以进站\"); if daoLenght &lt; 10: print(\"通过安检\"); print(\"终于可以见到Ta了，美滋滋~~~\"); else: print(\"没有通过安检\"); print(\"刀子的长度超过规定，等待警察处理...\");else: print(\"没有车票，不能进站\"); print(\"亲爱的，那就下次见了，一票难求啊~~~~(&gt;_&lt;)~~~~\"); 练一练： 12情节描述：上公交车，并且可以有座位坐下要求：输入公交卡当前的余额，只要超过2元，就可以上公交车；如果空座位的数量大于0，就可以坐下 猜拳游戏 参考代码 12345678910import randomplayer = input('请输入：剪刀(0) 石头(1) 布(2):')player = int(player)computer = random.randint(0,2)if ((player == 0) and (computer == 2)) or ((player ==1) and (computer == 0)) or ((player == 2) and (computer == 1)): print('获胜，哈哈，你太厉害了')elif player == computer: print('平局，要不再来一局')else: print('输了，不要走，洗洗手接着来，决战到天亮') 循环结构#while循环#1234567while 条件: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)...else: 语句; 注意：循环中加入else是其他语言不具备的特点，不过基本上不建议使用 案例： 12345i=1;while i&lt;5: print('当前是第%d次执行循环'%i); i=i+1;print('循环退出'); 练一练 1、计算1~100的累积和（包含1和100） 1234567#计算1~100的累积和（包含1和100）i =1;sum=0;while i&lt;=100: sum=sum+i; i=i+1;print('100以内的所有数何为%d'%sum); 2、计算1~100之间偶数的累积和（包含1和100） 12345678#计算1~100之间偶数的累积和（包含1和100）i =1;sum=0;while i&lt;=100: if i%2==0: sum = sum + i; i=i+1;print('100以内的所有偶数和为%d'%sum); for循环#像while循环一样，for可以完成循环的功能。 在Python中 for循环可以遍历任何序列的项目，如一个列表或者一个字符串等。 1234for 临时变量 in 列表或者字符串等: 循环满足条件时执行的代码else: 循环不满足条件时执行的代码 案例1： 12345678910&gt;&gt;&gt; for i in 'kingdom':... print(i);... kingdom 案例2: 12345678910111213&gt;&gt;&gt; for i in 'kingdom':... print(i);... else:... print('测试数据');... kingdom测试数据 break和continue#break的作用：用来结束整个循环 案例： 1234567i = 0while i&lt;10: i = i+1 print('----') if i==5: break; print(i); continue的作用：用来结束本次循环，紧接着执行下一次的循环 案例: 1234567i = 0;while i&lt;10: i = i+1; print('----'); if i==5: continue; print(i); 巩固练习#1.从键盘获取用户名、密码，如果用户名和密码都正确（预先设定一个用户名和密码），那么就显示“欢迎进入xxx的世界”，否则提示密码或者用户名错误 2、打印三角形 12345** ** * ** * * ** * * * * 参考代码 12345678i=1;while i&lt;5 : j = 1; while j&lt;=i: print('*',end=''); j=j+1; print(''); i=i+1; 3、打印99乘法表 4、小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻 18.5-25：正常 25-28：过重 28-32：肥胖 高于32：严重肥胖 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"Python基础(二)","slug":"python_base/python_02","date":"2018-04-20T05:08:49.000Z","updated":"2018-05-31T13:49:25.000Z","comments":true,"path":"2018/04/20/python_base/python_02/","link":"","permalink":"http://baofengketang.com/2018/04/20/python_base/python_02/","excerpt":"","text":"编写第一个python程序 编写Python程序的方式一： 编写Python程序的方式二 Python中的注释 python程序中，中文支持 变量与类型 标示符和关键字 输出 输入 运算符 数据类型转换 编写第一个python程序#编写Python程序的方式一：#交互模式 打开终端，输入python3 ，输入python3表示用的python这门编程语言的第3个版本，如果只输入python的话表示用的是python的第2个版本 输出”helloworld” 12&gt;&gt;&gt; print('helloworld');helloworld 交互模式可以用来进行测试知识点,测试完毕后可以使用exit()，进行退出 12345678jinzhongdeMacBook-Pro:bin jinzhong$ pythonPython 2.7.10 (default, Oct 23 2015, 19:19:21) [GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.59.5)] on darwinType \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; print('hello')hello&gt;&gt;&gt; exit()jinzhongdeMacBook-Pro:bin jinzhong$ 编写Python程序的方式二#使用常用的编辑器，可以选择sublime或者vi等等，这里选择vi,创建一个文件，后缀名选择.py 1vi hello.py; 在hello.py文件中编写如下代码 1print('helloworld'); 运行： 123jinzhongdeMacBook-Pro:~ jinzhong$ python3 hello.pyhelloworldjinzhongdeMacBook-Pro:~ jinzhong$ 有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释： 12#!/usr/bin/env python3print('helloworld'); 然后，通过命令给hello.py以执行权限： 1chmod a+x hello.py; 就可以直接运行hello.py了，比如在Mac下运行： 12jinzhongdeMacBook-Pro:~ jinzhong$ ./hello.pyhelloworld Python中的注释#单行注释 以#开头，#右边的所有东西当做说明，而不是真正要执行的程序，起辅助说明作用 12#这是一个注释print('hello world') 多行注释 123456''' 这是多行注释'''\"\"\" 这也是多行注释\"\"\" python程序中，中文支持#如果直接在程序中用到了中文，比如 1print('你好世界'); 那么接下来我们直接运行 我们发现使用python3命令程序能够正常运行，但是使用python命令程序无法处理中文 如何解决？在程序的开头写入以下代码 12#coding=utf-8print('你好世界'); 接下来继续运行 注意： 在python的语法规范中推荐使用的方式： 12#-*- coding:utf-8 -*-print('你好世界'); 运行结果如上图 变量与类型#变量: 在程序中，有时我们需要对2个数据进行求和，那么该怎样做呢？ 大家类比一下现实生活中，比如去超市买东西，往往咱们需要一个菜篮子，用来进行存储物品，等到所有的物品都购买完成后，在收银台进行结账即可 如果在程序中，需要把2个数据，或者多个数据进行求和的话，那么就需要把这些数据先存储起来，然后把它们累加起来即可 在Python中，存储一个数据，需要一个叫做变量的东西，如下示例 123456#-*- coding:utf-8 -*-print('你好世界');num1 = 100 ;num2 = 87 ;result = num1+num2;print(result); 说明: 所谓变量，可以理解为菜篮子，如果需要存储多个数据，最简单的方式是有多个变量，当然了也可以使用一个 程序就是用来处理数据的，而变量就是用来存储数据的 变量的类型： Python中变量的数据类型有如下几种： 怎样知道一个变量的类型呢？ 在python中，只要定义了一个变量，而且它有数据，那么它的类型就已经确定了，不需要咱们开发者主动的去说明它的类型，系统会自动辨别可以使用type(变量的名字)，来查看变量的类型 标示符和关键字#标示符 什么是标示符，看下图 开发人员在程序中自定义的一些符号和名称 标示符是自己定义的,如变量名 、函数名等 标示符的规则 标示符由字母、下划线和数字组成，且数字不能开头 python中的标识符是区分大小写的 命名规则 见名知意:起一个有意义的名字，尽量做到看一眼就知道是什么意思(提高代码可 读性) 比如: 名字 就定义为 name , 定义学生 用 student 驼峰命名法 小驼峰式命名法（lower camel case）： 第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName、aDog 大驼峰式命名法（upper camel case）： 每一个单字的首字母都采用大写字母，例如：FirstName、LastName 不过在程序员中还有一种命名法比较流行，就是用下划线“_”来连接所有的单词，比如send_buf 关键字 什么是关键字? python一些具有特殊功能的标示符，这就是所谓的关键字 关键字，是python已经使用的了，所以不允许开发者自己定义和关键字相同的名字的标示符 查看关键字: 123456789 False def if raiseNone del import returnTrue elif in tryand else is while as except lambda with assert finally nonlocal yield break for not class from or continue global pass 可以通过以下命令进行查看当前系统中python的关键字 关键字的学习以及使用，我们在后面的文章中插入讲解 输出#普通的输出 1print('hello world') print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出： 12&gt;&gt;&gt; print(\"helloworld\",\"kingdom\")helloworld kingdom print()函数遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的 也可以打印整数，或者计算结果： 12&gt;&gt;&gt; print('10+20=',(10+20))10+20= 30 格式化输出 在程序中，看到了%这样的操作符，这就是Python中格式化输出。 123age = 18name = \"xiaohua\"print(\"我的姓名是%s,年龄是%d\"%(name,age)) 常用的格式符号 格式符号 转换 ％c 字符 ％s 通过str() 字符串转换来格式化 %i 有符号十进制整数 %d 有符号十进制整数 %u 无符号十进制整数 %o 八进制整数 %x 十六进制整数（小写字母） %X 十六进制整数（大写字母） %e 索引符号（小写’e’） %E 索引符号（大写“E”） %f 浮点实数 %g ％f和％e 的简写 %G ％f和％E的简写 换行输出 在输出的时候，如果有\\n那么，此时\\n后的内容会在另外一行显示 123#-*- coding:utf-8 -*-print(\"1234567890-------\") # 会在一行显示print(\"1234567890\\n-------\") # ---会另起一行显示 对于print函数而言，print中两个参数的使用 end sep 其中end是设置输出值最后要添加的内容，默认是\\n，这也是为什么print会换行的原因 123#设置end=\"\"，将不会自动换行print(\"今天天气不错。\",end=\"\")print(\"我们去游泳！\") sep是用于输出多个字符串的使用如果希望使用指定的分隔符分割 1print(&quot;赵&quot;,&quot;钱&quot;,&quot;孙&quot;,&quot;李&quot;,sep=&quot;-&quot;) 结果 1赵-钱-孙-李 输入#python2版本中使用raw_input() 在Python中，获取键盘输入的数据的方法是采用 raw_input 函数,那么这个 raw_input 怎么用呢? 看如下示例: 123#-*- coding:utf-8 -*-password = raw_input(\"请输入密码:\");print '您刚刚输入的密码是:', password 运行结果： 注意: raw_input()的小括号中放入的是，提示信息，用来在获取数据之前给用户的一个简单提示raw_input()在从键盘获取了数据以后，会存放到等号右边的变量中raw_input()会把用户输入的任何值都作为字符串来对待 python2版本中input() input()函数与raw_input()类似，但其接受的输入必须是表达式。 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; a = input() 123&gt;&gt;&gt; a123&gt;&gt;&gt; type(a)&lt;type 'int'&gt;&gt;&gt;&gt; a = input()abcTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"&lt;string&gt;\", line 1, in &lt;module&gt;NameError: name 'abc' is not defined&gt;&gt;&gt; a = input()\"abc\"&gt;&gt;&gt; a'abc'&gt;&gt;&gt; type(a)&lt;type 'str'&gt;&gt;&gt;&gt; a = input()1+3&gt;&gt;&gt; a4&gt;&gt;&gt; a = input()\"abc\"+\"def\"&gt;&gt;&gt; a'abcdef'&gt;&gt;&gt; value = 100&gt;&gt;&gt; a = input()value&gt;&gt;&gt; a100 input()接受表达式输入，并把表达式的结果赋值给等号左边的变量 python3版本中 没有raw_input()函数，只有input() 并且 python3中的input与python2中的raw_input()功能一样 运算符#算术运算符 运算符 描述 实例 ＋ 加 两个对象相加 a + b 输出结果 30 － 减 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 ／ 除 x除以y b / a 输出结果 2 // 取整除 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 % 取余 返回除法的余数 b % a 输出结果 0 ** 幂 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 1234567891011&gt;&gt;&gt; 3+36&gt;&gt;&gt; 5/31.6666666666666667&gt;&gt;&gt; 5//31&gt;&gt;&gt; 5%32&gt;&gt;&gt; 2**38&gt;&gt;&gt; 赋值运算符 运算符 描述 实例 ＝ 赋值运算符 把=号右边的结果给左边的变量, num=1+2*3 结果num的值为7 12345&gt;&gt;&gt; a,b=3,6&gt;&gt;&gt; a3&gt;&gt;&gt; b6 复合赋值运算符 运算符 描述 实例 += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c *= a 等效于 c = c\\*a //= 取整除赋值运算符 c //=a 等效于 c = c // a **比较(即关系)运算符 运算符 描述 实例 == 检查两个操作数的值是否相等，如果是则条件变为真。 如a=3,b=3则（a == b) 为 true. != 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a != b) 为 true. &lt;&gt; 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a &lt;&gt; b) 为 true。这个类似于 != 运算符 &gt; 检查左操作数的值是否大于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a &gt; b) 为 true. &lt; 检查左操作数的值是否小于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a &lt; b) 为 false. &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a &gt;= b) 为 true. &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a &lt;= b) 为 true. 逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 True，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 数据类型转换# 函数 说明 int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 案例 12345678910#希望动态输入银行卡金额money=input(&quot;请输入您银行卡中的金额：&quot;)print(money)print(type(money))money = float(money) + 2;#float() 将字符串转换成float类型print(money)print(type(money))money=int(money)#可以将float类型转换成整型print(money)print(type(money)) 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"Python基础(一)","slug":"python_base/python_01","date":"2018-04-19T03:49:29.000Z","updated":"2018-05-31T13:49:26.000Z","comments":true,"path":"2018/04/19/python_base/python_01/","link":"","permalink":"http://baofengketang.com/2018/04/19/python_base/python_01/","excerpt":"","text":"Python介绍 起源 一门语言的诞生 Python的优点 Python的缺点 Python的应用场景 Python介绍#起源#Python的作者，Guido von Rossum（吉多·范罗苏姆），荷兰人。1982年，Guido从阿姆斯特丹大学获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。 在那个时候，Guido接触并使用过诸如Pascal、C、Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。 这种编程方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间，即使他已经准确的知道了如何实现。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。 Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的数学和计算机研究所开发的。Guido在该研究所工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。 尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。除了硬件上的困难外，ABC语言的设计也存在一些致命的问题： 可拓展性差。ABC语言不是模块化语言。如果想在ABC语言中增加功能，比如对图形化的支持，就必须改动很多地方。 不能直接进行IO。ABC语言不能直接操作文件系统。尽管你可以通过诸如文本流的方式导入数据，但ABC无法直接读写文 件。输入输出的困难对于计算机语言来说是致命的。你能想像一个打不开车门的跑车么？ 过度革新。ABC用自然语言的方式来表达程序的意义。然而对于程序员来说，他们更习惯 用function或者define来定义一个函数。同样，程序员更习惯用等号来分配变量。尽管ABC语言很特别，但学习难度也很大。 传播困难。ABC编译器很大，必须被保存在磁带上。当时Guido在访问的时候，就必须有一个大磁带来给别人安装ABC编译器。 这样，ABC语言就很难快速传播。 1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。Guido作为一个语言设计爱好者，已经有过设计语言的尝试。这一次，也不过是一次纯粹的hacking行为 一门语言的诞生#1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了 ：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。 Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。 但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例，特别是C语言的惯例，比如回归等号赋值。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。 Python从一开始就特别在意可拓展性。Python可以在多个层次上拓展。从高层上，你可以直接引入. py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写. py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。 最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python。随后，Python拓展到研究所之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节。这一特征吸引了广大的程序员。 Python的优点#简单—Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样，尽管这个英语的要求非常严格！Python的这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。 易学—就如同你即将看到的一样，Python极其容易上手。前面已经提到了，Python有极其简单的语法。 免费、开源—Python是FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。这是为什么Python如此优秀的原因之一——它是由一群希望看到一个更加优秀的Python的人创造并经常改进着的。 高层语言—当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。 可移植性—由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就可以在下述任何平台上面运行。这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE甚至还有PocketPC、Symbian以及Google基于linux开发的Android平台！ 解释性—这一点需要一些解释。一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。而Python语言写的程序不需要编译成二进制代码。你可以直接从源代码运行程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。事实上，由于你不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用Python更加简单。由于你只需要把你的Python程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的Python程序更加易于移植。 面向对象—Python既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在“面向对象”的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如C++和Java相比，Python以一种非常强大又简单的方式实现面向对象编程。 可扩展性—如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。 丰富的库—Python标准库确实很庞大。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。记住，只要安装了Python，所有这些功能都是可用的。这被称作Python的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。 规范的代码—Python采用强制缩进的方式使得代码具有极佳的可读性 Python的缺点#运行速度，有速度要求的话，用C++改写关键部分吧。国内市场较小（国内以python来做主要开发的，目前只有一些web2.0公司）。但时间推移，目前很多国内软件公司，尤其是游戏公司，也开始规模使用他。中文资料匮乏（好的python中文资料屈指可数）。托社区的福，有几本优秀的教材已经被翻译了，但入门级教材多，高级内容还是只能看英语版。构架选择太多（没有像C#这样的官方.net构架，也没有像ruby由于历史较短，构架开发的相对集中。Ruby on Rails 构架开发中小型web程序天下无敌）。不过这也从另一个侧面说明，python比较优秀，吸引的人才多，项目也多 Python的应用场景#Web应用开发 Python经常被用于Web开发。比如，通过mod_wsgi模块，Apache可以运行用Python编写的Web程序。Python定义了WSGI标准应用接口来协调Http服务器与基于Python的Web程序之间的通信。一些Web框架，如Django,TurboGears,web2py,Zope等，可以让程序员轻松地开发和管理复杂的Web程序。 操作系统管理、服务器运维的自动化脚本 在很多操作系统里，Python是标准的系统组件。 大多数Linux发行版以及NetBSD、OpenBSD和Mac OS X都集成了Python，可以在终端下直接运行Python。有一些Linux发行版的安装器使用Python语言编写，比如Ubuntu的Ubiquity安装器,Red Hat Linux和Fedora的Anaconda安装器。Gentoo Linux使用Python来编写它的Portage包管理系统。Python标准库包含了多个调用操作系统功能的库。通过pywin32这个第三方软件 包，Python能够访问Windows的COM服务及其它Windows API。使用IronPython，Python程序能够直接调用.Net Framework。一般说来，Python编写的系统管理脚本在可读性、性能、代码重用度、扩展性几方面都优于普通的shell脚本。 科学计算 NumPy,SciPy,Matplotlib可以让Python程序员编写科学计算程序。 桌面软件 PyQt、PySide、wxPython、PyGTK是Python快速开发桌面应用程序的利器。 服务器软件（网络软件） Python对于各种网络协议的支持很完善，因此经常被用于编写服务器软件、网络爬虫。第三方库Twisted支持异步网络编程和多数标准的网络协议(包含客户端和服务器)，并且提供了多种工具，被广泛用于编写高性能的服务器软件。 游戏 很多游戏使用C++编写图形显示等高性能模块，而使用Python或者Lua编写游戏的逻辑、服务器。相较于Python，Lua的功能更简单、体积更小；而Python则支持更多的特性和数据类型。 构思实现，产品早期原型和迭代 YouTube、Google、Yahoo!、NASA都在内部大量地使用Python。 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://baofengketang.com/tags/Python/"}]},{"title":"编辑器之神－VIM","slug":"vim/vim_01","date":"2018-04-16T16:10:01.000Z","updated":"2018-05-31T13:49:13.000Z","comments":true,"path":"2018/04/17/vim/vim_01/","link":"","permalink":"http://baofengketang.com/2018/04/17/vim/vim_01/","excerpt":"","text":"VIM简介#vi是“Visual interface”的简称，它在Linux上的地位就仿佛Edit程序在DOS上一样。它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且用户可以根据自己的需要对其进行定制。Vi不是一个排版程序，它不象Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。 1234Vi有三种基本工作模式：+ 命令模式+ 文本输入模式+ 末行模式。 命令行模式#任何时候，不管用户处于何种模式，只要按一下ESC键，即可使Vi进入命令模式；我们在shell环境(提示符为$)下输入启动Vi命令，进入编辑器时，也是处于该模式下。在该模式下，用户可以输入各种合法的Vi命令，用于管理自己的文档。此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的Vi命令，则Vi在接受用户命令之后完成相应的动作。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是Vi的合法命令，vi会响铃报警 文本输入模式#在命令模式下输入插入命令i、附加命令a 、打开命令o、修改命令c、取代命令r或替换命令s都可以进入文本输入模式。在该模式下，用户输入的任何字符都被Vi当做文件内容保存起来，并将其显示在屏幕上。在文本输入过程中，若想回到命令模式下，按键ESC即可 末行模式#末行模式也称ex转义模式。在命令模式下，用户按“:”键即可进入末行模式下，此时Vi会在显示窗口的最后一行(通常也是屏幕的最后一行)显示一个“:”作为末行模式的提示符，等待用户输入命令。多数文件管理命令都是在此模式下执行的(如把编辑缓冲区的内容写到文件中等)。末行命令执行完后，Vi自动回到命令模式。例如： 1:sp newfile 则分出一个窗口编辑newfile文件。如果要从命令模式转换到编辑模式，可以键入命令a或者i；如果需要从文本模式返回，则按Esc键即可。在命令模式下输入“:”即可切换到末行模式，然后输入命令 vim基础操作#vim是从 vi 发展出来的一个文本编辑器 。代码补完、编译及错误跳转等方便编程的功能特别丰富 进入插入模式: 123456i: 在光标前插入一个字符a: 在光标后插入一个字符 o: 向下新开一行,插入行首 I: 插入行首 A: 插入行未 O: 向上新开一行,插入行首 进⼊命令模式: ESC:从插⼊模式或末⾏模式进⼊命令模式 移动光标: 12345678910111213141516171819202122232425h: 左移l: 右移j: 下移k: 上移H: 光标移动到当前屏幕上方M: 光标移动到当前屏幕中间⾏L: 光标移动到屏幕下方Ctr-f: 向下翻⼀屏Ctr-b: 向上翻⼀屏Ctr-d: 向下翻半屏Ctr-u: 向上翻半屏G:快速回到整个代码行的最后一行gg:快速回到整个代码的第一行20G:快速定位到第20行代码w: 向后跳一个单词的长度，即跳到下一个单词的开始处b: 向前跳一个单词的长度，即跳到上一个单词的开始处&#123;: 按段移动,上移&#125;: 按段移动,下移gg: 光标移动⽂件开头G: 光标移动到⽂件末尾 删除（剪切）命令: 12345678dd: 删除光标所在⾏,n dd 删除指定的⾏数 D: 从当前光标开始前切，一直到行末d0: 从当前光标开始前切，一只到行首dw: 删除光标开始位置的单词,包含光标所在字符x: 删除光标后⼀个字符,相当于 DelX: 删除光标前⼀个字符,相当于 Backspaceu: ⼀步⼀步撤销Ctr-r: 反撤销 复制粘贴: 123yy: 复制当前行,n yy: 复制 n 行 p: 在光标所在位置向下新开辟一行,粘贴 文本行移动: 1234v,V:选中一片&gt;&gt;: ⽂本⾏右移&lt;&lt;: ⽂本⾏左移.: 重复上一次操作的命令 替换操作: 12r: 替换当前字符 R: 替换当前行光标后的字符 查找命令: 123/: str查找n: 下一个N：上一个 替换命令: 把abc全部替换成123 1234末行模式下，将当前文件中的所有abc替换成123:%s/abc/123/g末行模式下，将第一行至第10行之间的abc替换成123:1, 10s/abc/123/g 末行模式： 123w:保存q:退出wq:保存并且退出 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"vim","slug":"vim","permalink":"http://baofengketang.com/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://baofengketang.com/tags/vim/"},{"name":"编辑器","slug":"编辑器","permalink":"http://baofengketang.com/tags/编辑器/"}]},{"title":"古诗词（一）","slug":"jinhaoze/number1","date":"2018-04-13T13:04:43.000Z","updated":"2018-04-23T14:38:57.000Z","comments":true,"path":"2018/04/13/jinhaoze/number1/","link":"","permalink":"http://baofengketang.com/2018/04/13/jinhaoze/number1/","excerpt":"","text":"静夜思(李白诗作)#床前明月光，疑是地上霜。#举头望明月，低头思故乡。# 春晓（唐代孟浩然诗作）#春眠不觉晓，处处闻啼鸟。#夜来风雨声，花落知多少。# 村居（清代诗人高鼎）#草长莺飞二月天，拂堤杨柳醉春烟。#儿童散学归来早，忙趁东风放纸鸢# 所见（清代诗人袁枚）#牧童骑黄牛，歌声振林樾。#意欲捕鸣蝉，忽然闭口立。# 小池（宋代诗人杨万里）#泉眼无声惜细流，树阴照水爱晴柔。#小荷才露尖尖角，早有蜻蜓立上头。#","categories":[{"name":"诗词","slug":"诗词","permalink":"http://baofengketang.com/categories/诗词/"}],"tags":[{"name":"诗词","slug":"诗词","permalink":"http://baofengketang.com/tags/诗词/"}]},{"title":"Linux基础（二）","slug":"linux/linux_02","date":"2018-04-13T09:39:43.000Z","updated":"2018-06-14T07:45:16.000Z","comments":true,"path":"2018/04/13/linux/linux_02/","link":"","permalink":"http://baofengketang.com/2018/04/13/linux/linux_02/","excerpt":"","text":"Linux系统的常用命令操作 命令的格式 查看帮助文档 文件与目录 Linux命令 Linux系统的常用命令操作#命令的格式#1command [-options] [parameter1] … 说明： command: 命令名,相应功能的英⽂单词或单词的缩写 [-options]： 选项,可⽤来对命令进⾏控制， 也可以省略， []代表可选 parameter1 …： 传给命令的参数： 可以是零个⼀个或多个 案例： 查看帮助文档#–help ⼀般是linux命令⾃带的帮助信息 如： ls –help man( manual) man是linux提供的⼀个⼿册， 包含了绝⼤部分的命令、 函数使⽤说明该⼿册分成很多章节（section） ， 使⽤man时可以指定不同的章节来浏览。 例： man ls ; man 2 printf man中各个section意义如下： Standard commands（标准命令） System calls（系统调⽤， 如open,write） Library functions（库函数， 如printf,fopen） Special devices（设备⽂件的说明， /dev下各种设备） File formats（⽂件格式， 如passwd） Games and toys（游戏和娱乐） Miscellaneous（杂项、 惯例与协定等， 例如Linux档案系统、 ⽹络协定、 ASCII 码；environ全局变量） Administrative Commands（管理员命令， 如ifconfig） man是按照⼿册的章节号的顺序进⾏搜索的 man设置了如下的功能键： 自动补全 在敲出命令的前⼏个字⺟的同时， 按下tab键， 系统会⾃动帮我们补全命令 历史命令 当系统执⾏过⼀些命令后， 可按上下键翻看以前的命令， history将执⾏过的命令列举出来 文件与目录#在 windows 平台下， 打开“计算机”， 我们看到的是⼀个个的驱动器盘， 每个驱动器都有⾃⼰的根⽬录结构， 这样形成了多个树并列的情形。在 Linux 下， 我们是看不到这些驱动器盘符， 我们看到的是⽂件夹（⽬录） Unix系统的目录结构（了解） /： 根⽬录， ⼀般根⽬录下只存放⽬录， 在Linux下有且只有⼀个根⽬录。 所有的东⻄都是从这⾥开始。 当你在终端⾥输⼊“/home”， 你其实是在告诉电脑， 先从/（根⽬录） 开始， 再进⼊到home⽬录。 /bin、 /usr/bin: 可执⾏⼆进制⽂件的⽬录， 如常⽤的命令ls、 tar、 mv、 cat等。 /boot： 放置linux系统启动时⽤到的⼀些⽂件， 如Linux的内核⽂件： /boot/vmlinuz，系统引导管理器： /boot/grub。 /dev： 存放linux系统下的设备⽂件， 访问该⽬录下某个⽂件， 相当于访问某个设备，常⽤的是挂载光驱 mount /dev/cdrom /mnt。 /etc： 系统配置⽂件存放的⽬录， 不建议在此⽬录下存放可执⾏⽂件 /home： 系统默认的⽤户家⽬录， 新增⽤户账号时， ⽤户的家⽬录都存放在此⽬下， ~表示当前⽤户的家⽬录， ~edu 表示⽤户 edu 的家⽬录。 /lib、 /usr/lib、 /usr/local/lib： 系统使⽤的函数库的⽬录， 程序在执⾏过程中， 需要调⽤⼀些额外的参数时需要函数库的协助。 /lost+fount： 系统异常产⽣错误时， 会将⼀些遗失的⽚段放置于此⽬录下。/mnt: /media： 光盘默认挂载点， 通常光盘挂载于 /mnt/cdrom 下， 也不⼀定， 可以选择任意位置进⾏挂载。 /opt： 给主机额外安装软件所摆放的⽬录。 /proc： 此⽬录的数据都在内存中， 如系统核⼼， 外部设备， ⽹络状态， 由于数据都存放于内存中， 所以不占⽤磁盘空间， ⽐较重要的⽬录有/proc/cpuinfo、 /proc/interrupts、 /proc/dma、 /proc/ioports、/proc/net/* 等。 /root： 系统管理员root的家⽬录。 /sbin、 /usr/sbin、 /usr/local/sbin： 放置系统管理员使⽤的可执⾏命令， 如fdisk、shutdown、 mount 等。 与 /bin 不同的是， 这⼏个⽬录是给系统管理员 root使⽤的命令， ⼀般⽤户只能”查看”⽽不能设置和使⽤。 /tmp： ⼀般⽤户或正在执⾏的程序临时存放⽂件的⽬录， 任何⼈都可以访问， 重要数据不可放置在此⽬下。 /srv： 服务启动之后需要访问的数据⽬录， 如 www 服务需要访问的⽹⻚数据存放在/srv/www 内。 /usr： 应⽤程序存放⽬录， /usr/bin 存放应⽤程序， /usr/share 存放共享数据， /usr/lib存放不能直接运⾏的， 却是许多程序运⾏所必需的⼀些函数库⽂件。 /usr/local: 存放软件升级包。 /usr/share/doc: 系统说明⽂件存放⽬录。 /usr/share/man: 程序说明⽂件存放⽬录。 /var： 放置系统执⾏过程中经常变化的⽂件， 如随时更改的⽇志⽂件 /var/log， /var/log/message： 所有的登录⽂件存放⽬录， /var/spool/mail： 邮件存放的⽬录， /var/run:程序或服务启动后， 其PID存放在该⽬录下 用户目录（重点） 位于/home/user， 称之为⽤户⼯作⽬录或家⽬录,表示⽅式 123jinzhong@ubuntu:~$ cd ~jinzhong@ubuntu:~$ pwd/home/jinzhong ​ 相对路径与绝对路径 绝对路径： 从/⽬录开始描述的路径为绝对路径 123jinzhong@ubuntu:~$ cd /home/jinzhong/jinzhong@ubuntu:~$ pwd/home/jinzhong 相对路径: 从当前位置开始描述的路径为相对路径 1234567jinzhong@ubuntu:~$ cd .jinzhong@ubuntu:~$ pwd/home/jinzhongjinzhong@ubuntu:~$ cd ..jinzhong@ubuntu:/home$ pwd/homejinzhong@ubuntu:/home$ .和.. 每个⽬录下都有.和.. . 表示当前⽬录 .. 表示上⼀级⽬录， 即⽗⽬录 根⽬录下的.和..都表示当前⽬录 12345cd:切换工作目录cd ~ :切换到家目录cd .:切换到当前目录cd ..:切换到上级目录cd -:切换到上次所在目录 ​ Linux命令#打开终端： ​ 放大：ctrl+shift++ ​ 缩小：ctrl+- ls命令:显示目录中的文件 ls支持通配符 通配符 描述 ＊ ⽂件代表⽂件名中所有字符 ls te* 查找以te开头的⽂ ls *html 查找结尾为html的⽂件 ？ 代表⽂件名中任意⼀个字符 ls ?.c 只找第⼀个字符任意， 后缀为.c的⽂件 ls a.? 只找只有3个字符， 前2字符为a.， 最后⼀个字符任意的文件 [] [”和“]”将字符组括起来， 表示可以匹配字符组中的任意⼀个。 “-”⽤于表示字符范围。 [abc] 匹配a、 b、 c中的任意⼀个 [a-f] 匹配从a到f范围内的的任意⼀个字符 ls [a-f]* 找到从a到f范围内的的任意⼀个字符开头的⽂件 ls a-f 查找⽂件名为a-f的⽂件,当“-”处于⽅括号之外失去通配符的作用 \\ 如果要使通配符作为普通字符使⽤， 可以在其前⾯加上转义字符。 “?”和“*”处于⽅括号内时不⽤使⽤转义字符就失去通配符的作⽤。 ls * 查找⽂件名为*a的⽂件 12345ls ：显示目录中的文件ls -a:显示目录中所有的文件，包含隐藏文件ls -al:显示目录中的所有文件，以列表形式显示clear:清屏pwd:显示当前路径 输出重定向命令 Linux允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。 如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 ) 123ls &gt;hello.txt:将显示的内容放在文件中ls&gt;&gt;world.txt:将显示的内容追加到文件中&gt;：会将文件原有的内容删除，而&gt;&gt;不会 重定向可以和more结合使用 123将ls的内容放入到文件中，然后在采用more进行查看ls /bin -alh -&gt;hello.txtmore hello.txt 分屏显示（more） 查看内容时， 在信息过⻓⽆法在⼀屏上显示时， 会出现快速滚屏， 使得⽤户⽆法看清⽂件的内容， 此时可以使⽤more命令， 每次只显示⼀⻚， 按下空格键可以显示下⼀⻚， 按下q键退出显示， 按下h键可以获取帮助。 1234more hello.txtf:forwardb:backq:退出 创建目录 通过mkdir命令可以创建一个新的目录。参数-p可递归创建目录。 需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。 12mkdir 目录名：创建一个目录mkdir a/b/c/e -p:创建多级目录 删除目录 可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在rm后使用-i参数以逐个确认要删除的文件。 常用参数及含义如下表所示： 参数 含义 -i 以进行交互式方式执行 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹时必须加此参数 123rmdir 目录：删除目录，但是注意该目录中不能存在文件rm -rf 目录:递归删除目录rm:既可以删除文件，也可以删除文件夹 创建文件（在kingdom目录下） linux中如果文件以.开头，则这个文件为隐藏文件 1touch 文件：创建一个文件 查看文件 1cat 文件名：查看文件的内容 管道 管道：一个命令的输出可以通过管道做为另一个命令的输入。 管道我们可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里“ | ”的左右分为两端，左端塞东西(写)，右端取东西(读)。 改写上面的案例 1ls /bin -alh -&gt;hello.txt ｜more 链接 Linux链接文件类似于Windows下的快捷方式。 链接文件分为软链接和硬链接。 软链接：软链接不占用磁盘空间，源文件删除则软链接失效。 硬链接：硬链接只能链接普通文件，不能链接目录。 使用格式： 12ln 源文件 链接文件ln -s 源文件 链接文件 软连接：类比windows中的快捷方式，软连接不会增加硬连接的连接数量，源文件删除会影响到软连接 12创建一个1.txt的软连接，ln -s 1.txt 1_softlink.txt 硬连接：会增加硬连接的连接数量,原文件删除不会影响到影连接 1ln 1.txt 1_hardlink.txt 通过cat与重定向可以合并多个文件 将文件1与文件2的内容合并到new.txt文件中 1cat 文件1 文件2 &gt; new.txt 拷贝文件复制cp命令 cp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命令。 常用选项说明： 选项 含义 -a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。 -f 已经存在的目标文件而不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。 -v 显示拷贝进度 1cp 文件 /home/jinzhong -r 移动文件mv 用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。 常用选项说明： 选项 含义 -f 禁止交互式操作，如有覆盖也不会给出提示 -i 确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件 -v 显示移动进度 12剪切:mv 111.txt /home/jinzhong重命名:mv 源文件名 新文件名 文本搜索 Linux系统中grep命令是一种强大的文本搜索工具，grep允许对文本文件进行模式查找。如果找到匹配模式， grep打印包含模式的所有行。 grep一般格式为： 1grep [-选项] ‘搜索内容串’文件名 在grep命令中输入字符串参数时，最好引号或双引号括起来。例如：grep‘a ’1.txt。 常用选项说明： 选项 说明 -v 显示不包含匹配文本的所有行（相当于求反) -n 显示匹配行及行号 -i 忽略大小写 grep搜索内容串可以是正则表达式。 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 123grep &quot;ntfs&quot; hello.txt:查找文件中包含ntfs的文本grep -n &quot;ntfs&quot; hello.txt :显示位于哪一行grep &quot;^ntfs&quot; hello.txt:查找以ntfs开头的文本 查找文件：find find命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。 常用用法： 命令 含义 find ./ -name test.sh 查找当前目录下所有名为test.sh的文件 find ./ -name ‘*.sh’ 查找当前目录下所有后缀为.sh的文件 find ./ -name “[A-Z]*” 查找当前目录下所有以大写字母开头的文件 find /tmp -size 2M 查找在/tmp 目录下等于2M的文件 find /tmp -size +2M 查找在/tmp 目录下大于2M的文件 find /tmp -size -2M 查找在/tmp 目录下小于2M的文件 find ./ -size +4k -size -5M 查找当前目录下大于4k，小于5M的文件 find ./ -perm 777 查找当前目录下权限为 777 的文件或目录 归档与解压 计算机中的数据经常需要备份，tar是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。 1234将所有以txt结尾的文件打包称test.tar文件tar -cvf test.tar *.txt解包tar -xvf test.tar 压缩与解压缩 gz方式 1234压缩tar -zcvf test.tar.gz *.txt解压缩tar -zxvf test.tar.gz bz2方式 1234压缩tar -jcvf test.tar.bz2 *.txt解压缩tar -jxvf test.tar.bz2 zip方式 1234压缩zip hello.zip *.txt解压缩unzip hello.zip 欢迎扫描我的微信，进行技术交流","categories":[{"name":"linux","slug":"linux","permalink":"http://baofengketang.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://baofengketang.com/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://baofengketang.com/tags/操作系统/"}]},{"title":"Mybatis源码解析","slug":"mybatis/mybatis_01","date":"2018-04-13T07:48:19.000Z","updated":"2018-04-16T12:05:38.000Z","comments":true,"path":"2018/04/13/mybatis/mybatis_01/","link":"","permalink":"http://baofengketang.com/2018/04/13/mybatis/mybatis_01/","excerpt":"","text":"MyBatis入门#","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://baofengketang.com/categories/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://baofengketang.com/tags/mybatis/"}]},{"title":"Maven项目构建","slug":"maven/maven_01","date":"2018-04-11T02:39:13.000Z","updated":"2018-05-31T13:49:26.000Z","comments":true,"path":"2018/04/11/maven/maven_01/","link":"","permalink":"http://baofengketang.com/2018/04/11/maven/maven_01/","excerpt":"","text":"Maven项目构建 为什么要使用Maven 方便我们添加jar包 jar包之间的依赖问题 更加方便的获取第三方jar包 将项目拆分为多个工程模块 什么是Maven 什么是构建 构建的过程 自动化构建 Maven环境搭建 下载核心maven程序 检测Java环境 配置Maven的环境变量 验证环境是否搭建成功 Maven项目构建#Maven 是干什么用的？这是刚开始接触Maven 时最大的问题。之所以会提出这个问题，是因为即使不使用Maven，我们依然可以进行B/S 结构项目的开发。从表述层、业务逻辑层到持久化层再到数据库都有成熟的解决方案——不使用Maven我们一样可以开发项目 为什么要使用Maven#方便我们添加jar包#在今天JavaEE的开发领域，有大量的第三方框架和工具可以供我们使用，要使用这些jar包最简单的方法就是复制粘贴到WEB-INF/lib目录下，但是这会导致每次创建一个新的工程就需要将jar包重复复制lib目录下，从而造成工作区中存在大量重复的文件，让我们的工程显得很臃肿，而使用maven后每个jar包本身只在本地仓库保存一份，需要jar包的工程只需要以坐标的方式简单的引用一下就可以了，不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱 jar包之间的依赖问题#项目中jar包往往不是孤立存在的，很多jar包都需要在其他jar包的支持下才能够正常工作，我们称之为jar包之间的依赖关系，最典型的案例是：commons-fileupload-1.3.jar 依赖于commons-io-2.0.1.jar,如果没有io包，那么FileUpload包就不能够正常工作。 那么问题来了，你知道你所使用的jar包的依赖关系吗？当你拿到一个新的从未使用过的jar包，你如何知道它需要哪些jar包的支持呢?如果不了解这个情况，导入的jar包不够，那么现有的程序将不能正常工作，当你的项目中需要使用上百个jar包时，你还会认为的手工的逐一确认他们依赖的其他jar包吗？ 这简直不敢想象,而引入maven后，maven就可以替我们自动的将当前jar包所依赖的其他所有的jar包全部导入进来，无需人工参与，节约了我们大量的时间和精力，用实际例子来说明就是：通过 Maven导入commons-fileupload-1.3.jar 后commons-io-2.0.1.jar会被自动导入，程序员不必了解这个依赖关系 更加方便的获取第三方jar包#JavaEE开发中需要使用到的jar包种类繁多，几乎每个jar包在其本身的官网上的获取方式都不尽相同，为了查找一个jar包找遍整个互联网，身心俱惫，没有经历的人获取体会不到这种折磨，不仅如此费劲心血找的jar包里面有的时候并没有你需要的那个类，又或者有同名的类但是没没有你要的方法，以不规范的方式获得的jar包也是不规范的 使用maven我们可以享受到一个完全统一规范的jar包管理体系，你只需要在你的项目中以坐标的方式依赖一个jar包，maven就会自动从中央仓库进行下载，并同时下载这个jar包所依赖的其他jar包–&gt;规范、完整、准确！一次性解决所有问题 关于规范：统一的规范几乎可以说是程序员的最高信仰，如果没有规范，就意味着每个具体的技术都各自为政，需要以诸多不同的方式加入到项目中，好不容易加入进来后，可能还会与其他技术各个不入，最终受苦的是我们，而任何一个领域统一的规范可以极大的降低程序员的工作难度，减少工作量 在java中，我们一直提倡面向接口编程，而接口就是一种标准，一种规范。例如usb接口可以外接各种设备，如果每个设备都有自己独特的接口，那么不仅制造商需要维护各个接口的设计方案，使用者也需要详细了解每个设备 将项目拆分为多个工程模块#随着J2EE的项目的规模越来越大，开发团队的规模也与日剧增，一个项目上千人的团队开发很多年对于J2EE项目来说在正常不过了，那么我们想象一下：几百上千的人开发的项目是统一个web工程，那么架构师、项目经理该如何划分项目的模块、如何分工呢？这么大的项目已经不可能通过package结构来划分模块了，必须将项目拆分为多个工程协同开发，多个模块工程中有的是java工程，有的是web工程，那么工程拆分为后如何进行互相调用和访问呢？这就需要使用maven的依赖管理机制 什么是Maven#Maven是Apache软件基金会组织维护的一款自动化构建工具，专注服务于java平台的项目构建和依赖管理，maven这个单词的本意是：专家、内行。构建工具的历程：Ant-Maven(大部分项目中依然使用)-Gradle 什么是构建#构建并不是创建，创建一个工程并不等同于构建一个项目，要了解构建的含义，我们从以下几个层面来阐述 Java工程#大家都知道，java是一门编译型语言，.java的扩展名的源文件需要编译成.class扩展名的字节码文件才能够执行，所以编写任何java代码想要执行的话就必须经过编译得到对应的class文件 web工程#当我们需要通过浏览器访问java程序时就必须将包含java程序的web工程编译的结果放到服务器上的指定目录下，并启动服务器才行，这个过程我们称之为”部署” 总结#在实际项目中整合第三方框架，web工程中除了java程序和jsp页面、图片等静态资源外，还包括第三方框架的jar包以及各种各样的配置文件，所有这些资源都必须按照正确的目录部署到服务器上才能够运行。所以综上所述：构建就是以我们编写的java的代码、框架配置文件、国家化等其他资源文件、jsp页面和图片静态资源作为原材料，去生产出一个可以运行的的项目过程。 构建的过程#①清理：删除以前的编译结果，为重新编译做好准备 ②编译：将java源程序编译为字节码文件 ③测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性 ④报告：在每次测试后以标准的格式记录和展示测试结果 ⑤打包：在一个包含诸多文件的工程封装为一个压缩文件用于安装或部署，java工程对应jar包，web工程对应war包 ⑥安装：在maven环境下特指将打包的结果–jar包或者war包安装到本地仓库中 ⑦部署：将打包的结果部署到远程仓库或者war包部署到服务器上运行 自动化构建#综上所述，我们在eclipse中都可以找到对应的操作，只是不太标准，那么既然IDE已经可以进行构建了，我们为什么还要使用maven这样的构建工具呢？，下面我们来看一个小故事：张三在工作中，某天，测试项目中跟他说系统中有一个bug，这个时候，张三需要进入IDE,运行自己的程序、编译、打包、部署到服务器、在进行测试–&gt;确立问题，接下来开始修复bug，修复完毕后，他又要重新开始编译、打包、部署、测试，确认没有问题了，在通知项目组进行测试 在这个过程中，我们发现了张三的工作大部分花在了“编译、打包、部署、测试”这些固定化的工作上面，而真正需要由“人”的智慧实现的分析问题和编码却只占了很少一部分，我们能否将这些固定的工作交给机器自动完成–&gt;当然可以，这就是自动化构建，此时maven的意义就体现出来了，它可以自动的从构建过的程序起点一直执行到终点。 Maven环境搭建#下载核心maven程序# 检测Java环境# 配置Maven的环境变量# 验证环境是否搭建成功#好了，如果看到上图就表示，我们就可以使用maven来构建项目了 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"项目构建","slug":"项目构建","permalink":"http://baofengketang.com/categories/项目构建/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://baofengketang.com/tags/maven/"},{"name":"项目构建","slug":"项目构建","permalink":"http://baofengketang.com/tags/项目构建/"}]},{"title":"Java8学习笔记（一）","slug":"java/java01","date":"2018-04-10T05:11:58.000Z","updated":"2018-05-31T13:44:29.000Z","comments":true,"path":"2018/04/10/java/java01/","link":"","permalink":"http://baofengketang.com/2018/04/10/java/java01/","excerpt":"","text":"Java8学习笔记（一） 什么是Lambda 为什么要使用Lambda表达式 Java匿名内部类带来的问题 Lambda表达式的基本结构 总结1： Java8学习笔记（一）#什么是Lambda#In programming languages such as Lisp,Pythson and Ruby Lambda is an operator used to denote anonymous function or closures,following the usage of lambda calculus 为什么要使用Lambda表达式#​ 在java中，我们无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法,在javascript中，函数参数是一个函数，返回值是另一个函数的情况是非常常见的，javascript是一门非常典型的函数式语言 Java匿名内部类带来的问题#我们在之前学习java的时候，经常会写以下类似的代码 123456789101112131415161718package cn.org.kingdom.jdk8.day01;import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class TestDemo01 &#123; public static void main(String[] args) &#123; JFrame jframe = new JFrame(\"测试窗口\"); JButton jbtn = new JButton(\"测试按钮\"); jbtn.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent arg0) &#123; System.out.println(\"测试按钮被点击了\"); &#125; &#125;); jframe.add(jbtn); jframe.setDefaultCloseOperation(3); jframe.setVisible(true); &#125;&#125; 以上代码，关键部分就是执行按钮被点击后的核心操作，但是却使用了大量的冗余代码，那么使用Lambda表达式可以有效地简化以上代码 12345678910111213141516package cn.org.kingdom.jdk8.day01;import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class TestDemo02 &#123; public static void main(String[] args) &#123; JFrame jframe = new JFrame(\"测试窗口\"); JButton jbtn = new JButton(\"测试按钮\"); jbtn.addActionListener(e-&gt;&#123; System.out.println(\"按钮被点击了\"); &#125;); jframe.add(jbtn); jframe.setDefaultCloseOperation(3); jframe.setVisible(true); &#125;&#125; 有人可能会问了，以上例子中e的类型是什么？e的类型是java7开始加入的类型推断机制，有些时候是推断不出来的，需要我们自己显示定义 12345678910111213141516package cn.org.kingdom.jdk8.day01;import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class TestDemo02 &#123; public static void main(String[] args) &#123; JFrame jframe = new JFrame(\"测试窗口\"); JButton jbtn = new JButton(\"测试按钮\"); jbtn.addActionListener((ActionEvent e)-&gt;&#123; System.out.println(\"按钮被点击了\"); &#125;); jframe.add(jbtn); jframe.setDefaultCloseOperation(3); jframe.setVisible(true); &#125;&#125; Lambda表达式的基本结构#123（param1,param2,...）-&gt;&#123; statemnt;&#125; 在看一个案例 12345678910111213141516171819202122232425package cn.org.kingdom.jdk8.day01;import java.util.Arrays;import java.util.List;import java.util.function.Consumer;public class TestDemo04 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(11,23,43,23,25); //早期的遍历方式 for (int i = 0 ;i&lt;list.size();i++) &#123; System.out.println(list.get(i)); &#125; System.out.println(\"*******************************\"); //增强的for循环 for (Integer i:list)&#123; System.out.println(i); &#125; System.out.println(\"================================\"); list.forEach(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) &#123; System.out.println(integer); &#125; &#125;); &#125;&#125; 此时我们重点来研究一下最后一种方式，对于这种方式也采用了匿名内部类来实现的。很显然如果使用此种方式来进行输出，也是相当麻烦，此时我们不妨来看看这个接口的api说明 123456789101112131415161718192021222324252627282930313233343536373839package java.util.function;import java.util.Objects;/** * Represents an operation that accepts a single input argument and returns no * result. Unlike most other functional interfaces, &#123;@code Consumer&#125; is expected * to operate via side-effects. * * &lt;p&gt;This is a &lt;a href=\"package-summary.html\"&gt;functional interface&lt;/a&gt; * whose functional method is &#123;@link #accept(Object)&#125;. * * @param &lt;T&gt; the type of the input to the operation * * @since 1.8 */@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed &#123;@code Consumer&#125; that performs, in sequence, this * operation followed by the &#123;@code after&#125; operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the &#123;@code after&#125; operation will not be performed. * * @param after the operation to perform after this operation * @return a composed &#123;@code Consumer&#125; that performs in sequence this * operation followed by the &#123;@code after&#125; operation * @throws NullPointerException if &#123;@code after&#125; is null */ default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125; 翻译如下： 1代表一个操作，这个操作接受一个单个的输入参数，并且不产生结果，和大多数函数接口不同的是，它可能会产生副作用，这是一个函数式接口，它的函数式方法是accept()方法 如果想研究这个接口，那么我们有必要在来看看这个接口的声明上有一个FunctionalInterface注解，继续观察这个注解的api说明文档 1234567891011121314151617181920212223242526272829303132333435363738394041package java.lang;import java.lang.annotation.*;/** * An informative annotation type used to indicate that an interface * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as * defined by the Java Language Specification. * * Conceptually, a functional interface has exactly one abstract * method. Since &#123;@linkplain java.lang.reflect.Method#isDefault() * default methods&#125; have an implementation, they are not abstract. If * an interface declares an abstract method overriding one of the * public methods of &#123;@code java.lang.Object&#125;, that also does * &lt;em&gt;not&lt;/em&gt; count toward the interface's abstract method count * since any implementation of the interface will have an * implementation from &#123;@code java.lang.Object&#125; or elsewhere. * * &lt;p&gt;Note that instances of functional interfaces can be created with * lambda expressions, method references, or constructor references. * * &lt;p&gt;If a type is annotated with this annotation type, compilers are * required to generate an error message unless: * * &lt;ul&gt; * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class. * &lt;li&gt; The annotated type satisfies the requirements of a functional interface. * &lt;/ul&gt; * * &lt;p&gt;However, the compiler will treat any interface meeting the * definition of a functional interface as a functional interface * regardless of whether or not a &#123;@code FunctionalInterface&#125; * annotation is present on the interface declaration. * * @jls 4.3.2. The Class Object * @jls 9.8 Functional Interfaces * @jls 9.4.3 Interface Method Body * @since 1.8 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125; 翻译如下： 一个通知性的注解类型用于表示一个接口类型声明只在成为一个函数式接口（这个函数式接口是由java语言规范所定义的） 从概率上来看，一个函数式接口只有一个精确的抽象方法，由于java.reflect.method的isDefault方法有一个默认的实现，因此他们不是抽象的，如果一个接口声明了一个抽象方法重写了Object类的方法，它们也不能增加函数式接口中抽象方法的数量，因为接口的任意实现都有来自于object类或者其他地方的任意实现 注意一个函数式接口的实例可以通过lambda表达式、方法引用、构造引用来创建 如果一个类型被这种类型所表示，那么编译器被要求强制生成一个错误信息： 然而编译器对待任何一个接口，只要这个接口满足了函数式接口定义的要求，依然会将该接口当成一个函数式接口，而不管这个接口上是否加上了这么一个FunctionalInterface注解 总结1：#关于函数式接口 如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口 如果我们在某个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口 如果某个接口只有一个抽象方法，但我们并没有给该接口声明Functional注解，那么编译器依旧会将该接口看做函数式接口 接下来我们在看一个案例 12345678910111213141516171819202122232425262728293031package cn.org.kingdom.jdk8.day01;public class TestDemo03 &#123; public void test(MyInterface myInterface)&#123; System.out.println(\"**********\"); myInterface.test(); System.out.println(\"**********\"); &#125; public static void main(String[] args) &#123; TestDemo03 testDemo03 = new TestDemo03(); //匿名内部类实现 testDemo03.test(new MyInterface() &#123; @Override public void test() &#123; System.out.println(\"匿名内部类实现\"); &#125; &#125;); //lambda表达式实现 testDemo03.test(()-&gt;&#123; System.out.println(\"lambda表达式实现。。。。\"); &#125;); MyInterface myInterface=()-&gt;&#123;&#125;; System.out.println(\"myInterface:\"+myInterface); System.out.println(\"myInterface的类型：\"+myInterface.getClass()); System.out.println(myInterface.getClass().getInterfaces()[0]); &#125;&#125;@FunctionalInterfaceinterface MyInterface&#123; void test(); String toString();&#125; 运行结果如下： 123456789**********匿名内部类实现********************lambda表达式实现。。。。**********myInterface:cn.org.kingdom.jdk8.day01.TestDemo03$$Lambda$2/363771819@7b23ec81myInterface的类型：class cn.org.kingdom.jdk8.day01.TestDemo03$$Lambda$2/363771819interface cn.org.kingdom.jdk8.day01.MyInterface 接下来我们在回顾到上个案例中 123456789101112131415package cn.org.kingdom.jdk8.day01;import java.util.Arrays;import java.util.List;import java.util.function.Consumer;public class TestDemo04 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(11,23,43,23,25); list.forEach(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) &#123; System.out.println(integer); &#125; &#125;); &#125;&#125; 首先我们先研究一下list的foreach方法 12345678910111213141516171819202122232425/** * Performs the given action for each element of the &#123;@code Iterable&#125; * until all elements have been processed or the action throws an * exception. Unless otherwise specified by the implementing class, * actions are performed in the order of iteration (if an iteration order * is specified). Exceptions thrown by the action are relayed to the * caller. * * @implSpec * &lt;p&gt;The default implementation behaves as if: * &lt;pre&gt;&#123;@code * for (T t : this) * action.accept(t); * &#125;&lt;/pre&gt; * * @param action The action to be performed for each element * @throws NullPointerException if the specified action is null * @since 1.8 */ default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; api翻译如下： 1对这个迭代器的每个元素执行给定的动作，直到所有的元素都被处理完毕，或者说操作抛出了一个异常，如果没有被实现类所指定的话，动作会被按照迭代的顺序来执行是否抛出异常取决于调用者 此时我们可以回过头在看看Consumer接口的定义与描述,我们在此改写之前的代码 123456public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(11,23,43,23,25); list.forEach(e-&gt;&#123; System.out.println(e); &#125;);&#125; Lambda表达式为java添加了缺失的函数式编程特性，使我们能将函数当成一等公民看待 在将函数作为一等公民的语言中，Lambda表达式的类型是函数，但在java中，Lambda表达式是对象，他们必须依附一类特别的对象类型-函数式接口 也可以通过以下方式进行实现(方法引用的形式) 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(11,23,43,23,25); list.forEach(System.out::println);&#125; 好了，本篇就写到这里吧～～，大家可以操练一下，体会一下Lambda表达式给我们带来的便利之处 欢迎扫描我的微信，进行技术交流 同时也欢迎您的打赏，这将鼓励我写出更多的文章","categories":[{"name":"java","slug":"java","permalink":"http://baofengketang.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://baofengketang.com/tags/java/"}]}]}